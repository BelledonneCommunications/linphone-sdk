commit 9dd52e29fbaa42fb751e0e542fe435792a93d0f6
Author: Simon Morlat <simon.morlat@linphone.org>
Date:   Fri Jan 3 12:04:11 2014 +0100

    improve DNS resolver:
    - supports IPv6 DNS servers
    - supports nameserver lists with both IPv4 and IPv6 servers

diff --git a/src/dns.c b/src/dns.c
index cb5fcfa..167c114 100644
--- a/src/dns.c
+++ b/src/dns.c
@@ -5790,7 +5792,17 @@ int dns_so_submit(struct dns_socket *so, struct dns_packet *Q, struct sockaddr *
 	if ((error = dns_so_newanswer(so, DNS_SO_MINBUF)))
 		goto syerr;

-	memcpy(&so->remote, host, dns_sa_len(host));
+	if (so->local.ss_family==AF_INET6 && host->sa_family==AF_INET){
+		uint32_t *addr=(uint32_t*)dns_sa_addr(AF_INET6,&so->remote);
+		/* add v4mapping*/
+		so->remote.ss_family=AF_INET6;
+		addr[0]=0;
+		addr[1]=0;
+		addr[2]=ntohl(0xffff);
+		addr[3]=((struct sockaddr_in*)host)->sin_addr.s_addr;
+		*dns_sa_port(AF_INET6,&so->remote)=((struct sockaddr_in*)host)->sin_port;
+
+	}else memcpy(&so->remote, host, dns_sa_len(host));

 	so->query	= Q;
 	so->qout	= 0;
@@ -5916,31 +5928,47 @@ static int dns_so_tcp_recv(struct dns_socket *so) {
 #pragma clang diagnostic pop
 #endif

+#define USE_CONNECT 0

 int dns_so_check(struct dns_socket *so) {
 	int error;
 	long n;
+#if !USE_CONNECT
+	struct sockaddr_storage saddr;
+	socklen_t slen=sizeof(saddr);
+#endif

 retry:
 	switch (so->state) {
 	case DNS_SO_UDP_INIT:
 		so->state++;
 	case DNS_SO_UDP_CONN:
+#if USE_CONNECT
 		if (0 != connect(so->udp, (struct sockaddr *)&so->remote, dns_sa_len(&so->remote)))
 			goto soerr;
-
+#endif
 		so->state++;
 	case DNS_SO_UDP_SEND:
+#if USE_CONNECT
 		if (0 > (n = send(so->udp, (void *)so->query->data, so->query->end, 0)))
 			goto soerr;
-
+#else
+		if (0 > (n = sendto(so->udp, (void *)so->query->data, so->query->end, 0, (struct sockaddr *)&so->remote, dns_sa_len(&so->remote))))
+			goto soerr;
+#endif
 		so->stat.udp.sent.bytes += n;
 		so->stat.udp.sent.count++;

 		so->state++;
 	case DNS_SO_UDP_RECV:
+#if USE_CONNECT
 		if (0 > (n = recv(so->udp, (void *)so->answer->data, so->answer->size, 0)))
 			goto soerr;
+#else
+		if (0 > (n = recvfrom(so->udp, (void *)so->answer->data, so->answer->size, 0, (struct sockaddr*)&saddr,&slen)))
+			goto soerr;
+		/*TODO check if saddr matches one of the DNS server we previously sent a question, for security*/
+#endif

 		so->stat.udp.rcvd.bytes += n;
 		so->stat.udp.rcvd.count++;
@@ -6609,7 +6637,7 @@ static int dns_res_exec(struct dns_resolver *R) {
 	char host[DNS_D_MAXNAME + 1];
 	size_t len;
 	struct dns_rr rr;
-	struct sockaddr_in sin;
+	struct sockaddr_storage saddr={0};
 	int error;
 	struct dns_rr_i dns_rr_it;
 	int dns_grep_error;
@@ -6882,7 +6910,7 @@ exec:
 			goto error;

 		F->hints_j.name		= host;
-		F->hints_j.type		= DNS_T_A;
+		F->hints_j.type		= DNS_T_ALL;
 		F->hints_j.section	= DNS_S_ALL & ~DNS_S_QD;

 		if (!dns_rr_grep(&rr, 1, &F->hints_j, F->hints, &error)) {
@@ -6892,23 +6920,28 @@ exec:
 			goto(R->sp, DNS_R_FOREACH_NS);
 		}

-		sin.sin_family	= AF_INET;
+		saddr.ss_family	= rr.type==DNS_T_AAAA ? AF_INET6 : AF_INET;

-		if ((error = dns_a_parse((struct dns_a *)&sin.sin_addr, &rr, F->hints)))
-			goto error;
+		if (saddr.ss_family==AF_INET){
+			if ((error = dns_a_parse((struct dns_a *)dns_sa_addr(saddr.ss_family, &saddr), &rr, F->hints)))
+				goto error;
+		}else{
+			if ((error = dns_aaaa_parse((struct dns_aaaa *)dns_sa_addr(saddr.ss_family, &saddr), &rr, F->hints)))
+				goto error;
+		}

-		if (R->sp == 0)
-			sin.sin_port = dns_hints_port(R->hints, AF_INET, (struct sockaddr *)&sin.sin_addr);
-		else
-			sin.sin_port = htons(53);
+		*dns_sa_port(saddr.ss_family, &saddr) = (R->sp == 0) ? dns_hints_port(R->hints, saddr.ss_family, (struct sockaddr *)&saddr) : htons(53);
+

 		if (DNS_DEBUG) {
 			char addr[INET_ADDRSTRLEN + 1];
-			dns_a_print(addr, sizeof addr, (struct dns_a *)&sin.sin_addr);
+			if (saddr.ss_family==AF_INET)
+				dns_a_print(addr, sizeof addr, (struct dns_a *)dns_sa_addr(saddr.ss_family, &saddr));
+			else dns_aaaa_print(addr, sizeof addr, (struct dns_aaaa *)dns_sa_addr(saddr.ss_family, &saddr));
 			DNS_SHOW(F->query, "ASKING: %s/%s @ DEPTH: %u)", host, addr, R->sp);
 		}

-		if ((error = dns_so_submit(&R->so, F->query, (struct sockaddr *)&sin)))
+		if ((error = dns_so_submit(&R->so, F->query, (struct sockaddr *)&saddr)))
 			goto error;

 		F->state++;

