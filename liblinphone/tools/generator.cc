/*
linphone
Copyright (C) 2013 Belledonne Communications SARL
Simon Morlat (simon.morlat@linphone.org)

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/


#include <sstream>

#include "generator.hh"

#ifdef WIN32
#include <direct.h>
#endif


CplusplusGenerator::CplusplusGenerator(){
}

void CplusplusGenerator::generate(Project *proj){
	list<Class*> classes=proj->getClasses();
	mCurProj=proj;
#ifndef WIN32
	mkdir(proj->getName().c_str(),S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IROTH);
#else
	_mkdir(proj->getName().c_str());
#endif
	for_each(classes.begin(),classes.end(),bind1st(mem_fun(&CplusplusGenerator::writeClass),this));
}

void CplusplusGenerator::writeClass(Class *klass){
	ostringstream filename;
	
	if (klass->getType()!=Type::Class) return;
	filename<<mCurProj->getName()<<"/"<<klass->getName()<<".hh";
	mOutfile.open(filename.str().c_str());
	if (!mOutfile.is_open()){
		cerr<<"Could not write into "<<filename.str()<<endl;
		return;
	}
	const list<Method*> &methods=klass->getMethods();
	mCurClass=klass;
	mOutfile<<"/* Wrapper generated by lp-gen-wrappers, do not edit*/"<<endl;
	mOutfile<<endl;
	mOutfile<<"#include <string>"<<endl;
	mOutfile<<endl;
	if (!mCurProj->getName().empty())
		mOutfile<<"namespace "<<mCurProj->getName()<<"{"<<endl<<endl;
	mOutfile<<"class "<<klass->getName()<<"{"<<endl;
	mOutfile<<"public:"<<endl;
	for_each(methods.begin(),methods.end(),bind1st(mem_fun(&CplusplusGenerator::writeMethod),this));
	mOutfile<<"}"<<endl<<endl;
	if (!mCurProj->getName().empty())
		mOutfile<<"} //end of namespace "<<mCurProj->getName()<<endl;
	mOutfile<<endl;
	mOutfile.close();
}

void CplusplusGenerator::writeArgument(Argument *arg, bool isReturn){
	Type *type=arg->getType();
	
	if (type->getBasicType()==Type::Class){
		if (arg->isConst()){
			mOutfile<<"const ";
		}
		mOutfile<<type->getName();
		if (arg->isPointer())
			mOutfile<<"*";
	}else if (type->getBasicType()==Type::Integer){
		mOutfile<<"int";
	}else if (type->getBasicType()==Type::Enum){
		mOutfile<<type->getName();
	}else if (type->getBasicType()==Type::String){
		if (!isReturn)
			mOutfile<<"const std::string &";
		else 
			mOutfile<<"std::string";
	}else if (type->getBasicType()==Type::Void){
		mOutfile<<"void";
	}else if (type->getBasicType()==Type::Boolean){
		mOutfile<<"bool";
	}
	if (!isReturn && !arg->getName().empty())
		mOutfile<<" "<<arg->getName();
}

void CplusplusGenerator::writeTabs(int ntabs){
	int i;
	for(i=0;i<ntabs;++i)
		mOutfile<<"\t";
}

void CplusplusGenerator::writeHelpComment(const std::string &comment, int ntabs){
	size_t i;
	int curindex=0;
	writeTabs(ntabs);
	mOutfile<<" * ";
	for(i=0;i<comment.size();i++,curindex++){
		
		if (comment[i]=='\n' || (curindex>100 && comment[i]==' ')){
			mOutfile<<endl;
			writeTabs(ntabs);
			mOutfile<<" * ";
			curindex=0;
		}else mOutfile<<comment[i];
	}
}

void CplusplusGenerator::writeMethod(Method *method){
	Argument *retarg=method->getReturnArg();
	const list<Argument*> &args=method->getArgs();
	list<Argument*>::const_iterator it;
	
	writeTabs(1);
	mOutfile<<"/**"<<endl;
	writeHelpComment(method->getHelp(),1);
	mOutfile<<endl;
	writeTabs(1);
	mOutfile<<"**/"<<endl;
	
	writeTabs(1);
	writeArgument(retarg,true);
	mOutfile<<" "<<method->getName()<<"(";
	
	for(it=args.begin();it!=args.end();++it){
		if (it!=args.begin()) mOutfile<<", ";
		writeArgument(*it);
	}
	mOutfile<<")";
	if (method->isConst()) mOutfile<<"const";
	mOutfile<<";"<<endl;
	mOutfile<<endl;
}


JavascriptGenerator::JavascriptGenerator(){
}

void JavascriptGenerator::generate(Project *proj){
	list<Class*> classes=proj->getClasses();
	mCurProj=proj;
#ifndef WIN32
	unlink(proj->getName().c_str());
	mkdir(proj->getName().c_str(),S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IROTH);
#else
	_mkdir(proj->getName().c_str());
#endif
	for_each(classes.begin(),classes.end(),bind1st(mem_fun(&JavascriptGenerator::writeClass),this));
}

void JavascriptGenerator::writeClass(Class *klass){
	ostringstream filename;
	
	if (klass->getType()!=Type::Class) return;
	filename<<mCurProj->getName()<<"/"<<klass->getName()<<".js";
	mOutfile.open(filename.str().c_str());
	if (!mOutfile.is_open()){
		cerr<<"Could not write into "<<filename.str()<<endl;
		return;
	}
	const list<Method*> &methods=klass->getMethods();
	mCurClass=klass;
	mOutfile<<"/* Wrapper generated by lp-gen-wrappers, do not edit*/"<<endl;
	mOutfile<<endl;
	
	//if (!mCurProj->getName().empty())
	//	mOutfile<<"namespace "<<mCurProj->getName()<<"{"<<endl<<endl;
	mOutfile<<"/**"<<endl;
	mOutfile<<" * "<<klass->getHelp()<<endl;
	mOutfile<<" * @external "<<klass->getName()<<endl;
	mOutfile<<"**/"<<endl;
	
	list<Property*> properties=klass->getProperties();
	for_each(properties.begin(),properties.end(),bind1st(mem_fun(&JavascriptGenerator::writeProperty),this));
	mOutfile<<endl;
	for_each(methods.begin(),methods.end(),bind1st(mem_fun(&JavascriptGenerator::writeMethod),this));
	//if (!mCurProj->getName().empty())
	//	mOutfile<<"} //end of namespace "<<mCurProj->getName()<<endl;
	mOutfile<<endl;
	mOutfile.close();
}

void JavascriptGenerator::writeType(Type *type){
	switch(type->getBasicType()){
		case Type::Float:
		case Type::Integer:
			mOutfile<<"number";
		break;
		case Type::String:
			mOutfile<<"string";
		break;
		case Type::Boolean:
			mOutfile<<"boolean";
		break;
		case Type::Class:
		case Type::Enum:
			mOutfile<<"external:"<<type->getName();
		break;
		case Type::Void:
			mOutfile<<"void";
		break;
		case Type::Callback:
		break;
	}
}

void JavascriptGenerator::writeArgument(Argument *arg, bool isReturn){
	if (!isReturn){
		mOutfile<<" * @param {";
		writeType(arg->getType());
		mOutfile<<"} "<<arg->getName()<<" - "<<arg->getHelp()<<endl;
	}else{
		mOutfile<<" * @returns {";
		writeType(arg->getType());
		mOutfile<<"} "<<arg->getHelp()<<endl;
	}
}

void JavascriptGenerator::writeTabs(int ntabs){
	int i;
	for(i=0;i<ntabs;++i)
		mOutfile<<"\t";
}

void JavascriptGenerator::writeHelpComment(const std::string &comment, int ntabs){
	size_t i;
	int curindex=0;
	mOutfile<<" * ";
	for(i=0;i<comment.size();i++,curindex++){
		
		if (comment[i]=='\n' || (curindex>100 && comment[i]==' ')){
			mOutfile<<endl;
			mOutfile<<" * ";
			curindex=0;
		}else mOutfile<<comment[i];
	}
}

void JavascriptGenerator::writeProperty(Property *prop){
	mOutfile<<"/**"<<endl;
	writeHelpComment(prop->getHelp(),0);
	mOutfile<<endl;
	mOutfile<<" * @member {";
	writeType(prop->getType());
	mOutfile<<"} external:"<<mCurClass->getName()<<"#"<<prop->getName()<<endl;
	if (prop->getAttribute()==Property::ReadOnly)
		mOutfile<<" * @readonly"<<endl;
	mOutfile<<"**/"<<endl;
}

void JavascriptGenerator::writeMethod(Method *method){
	Argument *retarg=method->getReturnArg();
	const list<Argument*> &args=method->getArgs();
	list<Argument*>::const_iterator it;
	
	if (method->getPropertyBehaviour()!=Method::None) return;
	if (method->getName()=="ref" || method->getName()=="unref") return;
	
	mOutfile<<"/**"<<endl;
	writeHelpComment(method->getHelp(),0);
	mOutfile<<endl;
	mOutfile<<" * @function external:"<<mCurClass->getName()<<"#"<<method->getName()<<endl;
	
	for(it=args.begin();it!=args.end();++it){
		writeArgument(*it);
	}
	writeArgument(retarg,true);
	mOutfile<<"**/"<<endl;
	mOutfile<<endl;
}
