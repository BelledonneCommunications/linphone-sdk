/*
Copyright (C) 2014 Belledonne Communications SARL

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <Python.h>
#include <linphone/linphonecore.h>


static PyObject *logging_module = NULL;


static void init_logging(void) {
	logging_module = PyImport_ImportModule("logging");
	if (logging_module != NULL) {
		PyObject *constant;
		PyObject *func;
		PyObject *kws;
		long level = 0;

		constant = PyObject_GetAttrString(logging_module, "DEBUG");
		if (PyInt_Check(constant)) {
			level = PyInt_AsLong(constant);
		}
		Py_DECREF(constant);
		func = PyObject_GetAttrString(logging_module, "basicConfig");
		kws = Py_BuildValue("{s:i,s:s}", "level", level, "format", "%(levelname)s: %(message)s");
		PyEval_CallObjectWithKeywords(func, NULL, kws);
		Py_DECREF(kws);
		Py_DECREF(func);
	}
}

static void pylinphone_log(const char *level, const char *fmt) {
	if (logging_module != NULL) {
		PyEval_CallMethod(logging_module, level, "(s)", fmt);
	}
}

#define pylinphone_debug(fmt) pylinphone_log("debug", fmt)
#define pylinphone_info(fmt) pylinphone_log("info", fmt)
#define pylinphone_warning(fmt) pylinphone_log("warning", fmt)
#define pylinphone_trace pylinphone_debug


{{#classes}}
static PyTypeObject pylinphone_{{class_name}}Type;
{{/classes}}

{{#classes}}

typedef struct {
	PyObject_HEAD
	{{class_cname}} *native_ptr;
} pylinphone_{{class_name}}Object;

{{/classes}}

{{#classes}}

static {{class_cname}} * pylinphone_{{class_name}}_get_native_ptr(PyObject *self) {
	return ((pylinphone_{{class_name}}Object *)self)->native_ptr;
}

static PyObject * pylinphone_{{class_name}}_new_from_native_ptr(PyTypeObject *type, {{class_cname}} *native_ptr) {
{{{new_from_native_pointer_body}}}
}

static PyObject * pylinphone_{{class_name}}_new(PyTypeObject *type, PyObject *args, PyObject *kw) {
	pylinphone_{{class_name}}Object *self = (pylinphone_{{class_name}}Object *)type->tp_alloc(type, 0);
	pylinphone_trace(__FUNCTION__);
	self->native_ptr = NULL;
	return (PyObject *)self;
}

static void pylinphone_{{class_name}}_dealloc(PyObject *self) {
{{{dealloc_body}}}
}

{{#class_type_methods}}

static PyObject * pylinphone_{{class_name}}_class_method_{{method_name}}(PyObject *cls, PyObject *args) {
{{{method_body}}}
}

{{/class_type_methods}}

{{#class_instance_methods}}

static PyObject * pylinphone_{{class_name}}_instance_method_{{method_name}}(PyObject *self, PyObject *args) {
{{{method_body}}}
}

{{/class_instance_methods}}

static PyMethodDef pylinphone_{{class_name}}_instance_methods[] = {
	// TODO: Handle doc
	/* Class methods */
{{#class_type_methods}}
	{ "{{method_name}}", pylinphone_{{class_name}}_class_method_{{method_name}}, METH_VARARGS | METH_CLASS, "" },
{{/class_type_methods}}
	/* Instance methods */
{{#class_instance_methods}}
	{ "{{method_name}}", pylinphone_{{class_name}}_instance_method_{{method_name}}, METH_VARARGS, "" },
{{/class_instance_methods}}
	/* Sentinel */
	{ NULL, NULL, 0, NULL }
};

{{#class_properties}}

{{{getter_definition_begin}}}
{{{getter_body}}}
{{{getter_definition_end}}}

{{{setter_definition_begin}}}
{{{setter_body}}}
{{{setter_definition_end}}}

{{/class_properties}}

static PyGetSetDef pylinphone_{{class_name}}_getseters[] = {
	// TODO: Handle doc
{{#class_properties}}
	{ "{{property_name}}", {{getter_reference}}, {{setter_reference}}, "" },
{{/class_properties}}
	/* Sentinel */
	{ NULL, NULL, NULL, NULL, NULL }
};

static PyTypeObject pylinphone_{{class_name}}Type = {
	PyObject_HEAD_INIT(NULL)
	0,	/* ob_size */
	"linphone.{{class_name}}",	/* tp_name */
	sizeof(pylinphone_{{class_name}}Object),	/* tp_basicsize */
	0,	/* tp_itemsize */
	pylinphone_{{class_name}}_dealloc,	/* tp_dealloc */
	0,	/* tp_print */
	0,	/* tp_getattr */
	0,	/* tp_setattr */
	0,	/* tp_compare */
	0,	/* tp_repr */
	0,	/* tp_as_number */
	0,	/* tp_as_sequence */
	0,	/* tp_as_mapping */
	0,	/* tp_hash */
	0,	/* tp_call */
	0,	/* tp_str */
	0,	/* tp_getattro */
	0,	/* tp_setattro */
	0,	/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,	/* tp_flags */
	{{{class_doc}}},	/* tp_doc */
	0,	/* tp_traverse */
	0,	/* tp_clear */
	0,	/* tp_richcompare */
	0,	/* tp_weaklistoffset */
	0,	/* tp_iter */
	0,	/* tp_iternext */
	pylinphone_{{class_name}}_instance_methods,	/* tp_methods */
	0,	/* tp_members */
	pylinphone_{{class_name}}_getseters,	/* tp_getset */
	0,	/* tp_base */
	0,	/* tp_dict */
	0,	/* tp_descr_get */
	0,	/* tp_descr_set */
	0,	/* tp_dictoffset */
	0,	/* tp_init */
	0,	/* tp_alloc */
	pylinphone_{{class_name}}_new,	/* tp_new */
	0,	/* tp_free */
};

{{/classes}}

static PyMethodDef pylinphone_ModuleMethods[] = {
	/* Sentinel */
	{ NULL, NULL, 0, NULL }
};

static PyMethodDef pylinphone_NoMethods[] = {
	/* Sentinel */
	{ NULL, NULL, 0, NULL }
};

PyMODINIT_FUNC initlinphone(void) {
	PyObject *m;
	PyObject *menum;

	init_logging();

{{#classes}}
	if (PyType_Ready(&pylinphone_{{class_name}}Type) < 0) return;
{{/classes}}

	m = Py_InitModule3("linphone", pylinphone_ModuleMethods, "Python module giving access to the Linphone library.");
	if (m == NULL) return;

{{#enums}}
	menum = Py_InitModule3("{{enum_name}}", pylinphone_NoMethods, {{{enum_doc}}});
	if (menum == NULL) return;
	if (PyModule_AddObject(m, "{{enum_name}}", menum) < 0) return;
{{#enum_values}}
	if (PyModule_AddIntConstant(menum, "{{enum_value_name}}", {{enum_value_cname}}) < 0) return;
{{/enum_values}}
{{/enums}}

{{#classes}}
	Py_INCREF(&pylinphone_{{class_name}}Type);
	PyModule_AddObject(m, "{{class_name}}", (PyObject *)&pylinphone_{{class_name}}Type);
{{/classes}}
}
