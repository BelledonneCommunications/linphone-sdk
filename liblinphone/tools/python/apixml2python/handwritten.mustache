static void pylinphone_log(const char *level, int indent, const char *fmt, va_list args) {
	static int current_indent = 1;
	PyObject *linphone_module;
	PyGILState_STATE gstate;

	gstate = PyGILState_Ensure();
	linphone_module = PyImport_ImportModule("linphone");
	if ((linphone_module != NULL) && PyObject_HasAttrString(linphone_module, "__log_handler")) {
		PyObject *log_handler = PyObject_GetAttrString(linphone_module, "__log_handler");
		if ((log_handler != NULL) && PyFunction_Check(log_handler)) {
			char logstr[4096];
			int i = 0;
			if (indent == -1) current_indent--;
			if (current_indent < 1) current_indent = 1;
			if ((indent >= -1) && (indent <= 1)) {
				for (i = 0; i < current_indent; i++) {
					logstr[i] = '\t';
				}
			}
			if (indent == 1) current_indent++;
			if (vsnprintf(logstr + i, sizeof(logstr) - i, fmt, args) > 0) {
				PyEval_CallFunction(log_handler, "ss", level, logstr);
			}
			Py_DECREF(log_handler);
		}
		Py_DECREF(linphone_module);
	}
	PyGILState_Release(gstate);
}

static PYLINPHONE_INLINE void pylinphone_trace(int indent, const char *fmt, ...) {
	va_list args;
	va_start(args, fmt);
	pylinphone_log("debug", indent, fmt, args);
	va_end(args);
}

static const char * pylinphone_ortp_log_level_to_string(OrtpLogLevel lev) {
	switch (lev) {
		default:
		case ORTP_DEBUG:
			return "debug";
		case ORTP_MESSAGE:
			return "info";
		case ORTP_WARNING:
			return "warning";
		case ORTP_ERROR:
			return "error";
		case ORTP_FATAL:
			return "critical";
		case ORTP_TRACE:
			return "debug";
	}
}

static void pylinphone_module_log_handler(OrtpLogLevel lev, const char *fmt, va_list args) {
	PyGILState_STATE gstate;
	PyObject *linphone_module;
	const char *level;

	gstate = PyGILState_Ensure();
	linphone_module = PyImport_ImportModule("linphone");
	level = pylinphone_ortp_log_level_to_string(lev);
	if ((linphone_module != NULL) && PyObject_HasAttrString(linphone_module, "__log_handler")) {
		PyObject *log_handler = PyObject_GetAttrString(linphone_module, "__log_handler");
		if ((log_handler != NULL) && PyFunction_Check(log_handler)) {
			char logstr[4096];
			if (vsnprintf(logstr, sizeof(logstr), fmt, args) > 0) {
				if (PyEval_CallFunction(log_handler, "ss", level, logstr) == NULL) {
					PyErr_Print();
				}
			}
			Py_DECREF(log_handler);
		}
		Py_DECREF(linphone_module);
	}
	PyGILState_Release(gstate);
}

static void pylinphone_init_logging(void) {
	linphone_core_serialize_logs();
	linphone_core_set_log_handler(pylinphone_module_log_handler);
	linphone_core_set_log_level(ORTP_MESSAGE|ORTP_WARNING|ORTP_ERROR|ORTP_FATAL);
}


static PyObject * pylinphone_module_method_set_log_handler(PyObject *self, PyObject *args) {
	PyObject *linphone_module = PyImport_ImportModule("linphone");
	PyObject *callback;
	if (!PyArg_ParseTuple(args, "O", &callback)) {
		return NULL;
	}
	if (linphone_module != NULL) {
		Py_INCREF(callback);
		PyObject_SetAttrString(linphone_module, "__log_handler", callback);
		Py_DECREF(linphone_module);
	}
	Py_RETURN_NONE;
}

static PyObject * pylinphone_Core_class_method_new(PyObject *cls, PyObject *args) {
	LinphoneCore * cresult;
	pylinphone_CoreObject *self;
	PyObject * pyret;
	LinphoneCoreVTable _vtable = { 0 };
	PyObject * _vtable_dict;
	const char * _config_path;
	const char * _factory_config_path;

	if (!PyArg_ParseTuple(args, "Ozz", &_vtable_dict, &_config_path, &_factory_config_path)) {
		return NULL;
	}
	if (!PyDict_Check(_vtable_dict)) {
		PyErr_SetString(PyExc_TypeError, "The first argument must be a dictionary");
		return NULL;
	}

	self = (pylinphone_CoreObject *)PyObject_New(pylinphone_CoreObject, &pylinphone_CoreType);
	if (self == NULL) {
		return NULL;
	}
	Py_INCREF(_vtable_dict);
	self->vtable_dict = _vtable_dict;
{{#events}}
	{{{event_vtable_reference}}}
{{/events}}

	pylinphone_trace(1, "[PYLINPHONE] >>> %s(%p, \"%s\", \"%s\")", __FUNCTION__, _vtable_dict, _config_path, _factory_config_path);
	cresult = linphone_core_new(&_vtable, _config_path, _factory_config_path, self);
	self->native_ptr = cresult;

	pyret = Py_BuildValue("O", self);

	pylinphone_trace(-1, "[PYLINPHONE] <<< %s -> %p", __FUNCTION__, pyret);
	Py_DECREF(self);
	return pyret;
}

static PyObject * pylinphone_Core_class_method_new_with_config(PyObject *cls, PyObject *args) {
	LinphoneCore * cresult;
	pylinphone_CoreObject *self;
	PyObject * pyret;
	LinphoneCoreVTable _vtable = { 0 };
	PyObject * _vtable_dict;
	PyObject * _config;
	LpConfig * _config_native_ptr;

	if (!PyArg_ParseTuple(args, "OO", &_vtable_dict, &_config)) {
		return NULL;
	}
	if (!PyDict_Check(_vtable_dict)) {
		PyErr_SetString(PyExc_TypeError, "The first argument must be a dictionary");
		return NULL;
	}

	if ((_config_native_ptr = pylinphone_LpConfig_get_native_ptr(_config)) == NULL) {
		return NULL;
	}

	self = (pylinphone_CoreObject *)PyObject_New(pylinphone_CoreObject, &pylinphone_CoreType);
	if (self == NULL) {
		return NULL;
	}
	Py_INCREF(_vtable_dict);
	self->vtable_dict = _vtable_dict;
{{#events}}
	{{{event_vtable_reference}}}
{{/events}}

	pylinphone_trace(1, "[PYLINPHONE] >>> %s(%p [%p])", __FUNCTION__, _config, _config_native_ptr);
	cresult = linphone_core_new_with_config(&_vtable, _config_native_ptr, self);
	self->native_ptr = cresult;

	pyret = Py_BuildValue("O", self);

	pylinphone_trace(-1, "[PYLINPHONE] <<< %s -> %p", __FUNCTION__, pyret);
	Py_DECREF(self);
	return pyret;
}

static PyObject * pylinphone_Core_instance_method_iterate(PyObject *self, PyObject *args) {
	LinphoneCore *native_ptr = pylinphone_Core_get_native_ptr(self);
	if (native_ptr == NULL) {
		PyErr_SetString(PyExc_TypeError, "Invalid linphone.Core instance");
		return NULL;
	}

	pylinphone_trace(1, "[PYLINPHONE] >>> %s(%p [%p])", __FUNCTION__, self, native_ptr);
	linphone_core_iterate(native_ptr);
#ifdef WIN32
	{
		MSG msg;
		while (PeekMessage(&msg, NULL, 0, 0, 1)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
#endif

	pylinphone_trace(-1, "[PYLINPHONE] <<< %s -> None", __FUNCTION__);
	Py_RETURN_NONE;
}
