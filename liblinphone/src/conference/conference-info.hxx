// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX_USERS_REISBENJAMIN_DEVELOPPEMENT_FLEXISIP_SRC_XML_CONFERENCE_INFO_HXX
#define CXX_USERS_REISBENJAMIN_DEVELOPPEMENT_FLEXISIP_SRC_XML_CONFERENCE_INFO_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace conference_info
{
  class Conference_type;
  class State_type;
  class Conference_description_type;
  class Host_type;
  class Conference_state_type;
  class Conference_media_type;
  class Conference_medium_type;
  class Uris_type;
  class Uri_type;
  class Keywords_type;
  class Users_type;
  class User_type;
  class User_roles_type;
  class User_languages_type;
  class Endpoint_type;
  class Endpoint_status_type;
  class Joining_type;
  class Disconnection_type;
  class Execution_type;
  class Call_type;
  class Sip_dialog_id_type;
  class Media_type;
  class Media_status_type;
  class Sidebars_by_val_type;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

#include "xml.hxx"

namespace conference_info
{
  class Conference_type: public ::xml_schema::Type
  {
    public:
    // conference-description
    //
    typedef ::conference_info::Conference_description_type Conference_descriptionType;
    typedef ::xsd::cxx::tree::optional< Conference_descriptionType > Conference_descriptionOptional;
    typedef ::xsd::cxx::tree::traits< Conference_descriptionType, char > Conference_descriptionTraits;

    const Conference_descriptionOptional&
    getConference_description () const;

    Conference_descriptionOptional&
    getConference_description ();

    void
    setConference_description (const Conference_descriptionType& x);

    void
    setConference_description (const Conference_descriptionOptional& x);

    void
    setConference_description (::std::unique_ptr< Conference_descriptionType > p);

    // host-info
    //
    typedef ::conference_info::Host_type Host_infoType;
    typedef ::xsd::cxx::tree::optional< Host_infoType > Host_infoOptional;
    typedef ::xsd::cxx::tree::traits< Host_infoType, char > Host_infoTraits;

    const Host_infoOptional&
    getHost_info () const;

    Host_infoOptional&
    getHost_info ();

    void
    setHost_info (const Host_infoType& x);

    void
    setHost_info (const Host_infoOptional& x);

    void
    setHost_info (::std::unique_ptr< Host_infoType > p);

    // conference-state
    //
    typedef ::conference_info::Conference_state_type Conference_stateType;
    typedef ::xsd::cxx::tree::optional< Conference_stateType > Conference_stateOptional;
    typedef ::xsd::cxx::tree::traits< Conference_stateType, char > Conference_stateTraits;

    const Conference_stateOptional&
    getConference_state () const;

    Conference_stateOptional&
    getConference_state ();

    void
    setConference_state (const Conference_stateType& x);

    void
    setConference_state (const Conference_stateOptional& x);

    void
    setConference_state (::std::unique_ptr< Conference_stateType > p);

    // users
    //
    typedef ::conference_info::Users_type UsersType;
    typedef ::xsd::cxx::tree::optional< UsersType > UsersOptional;
    typedef ::xsd::cxx::tree::traits< UsersType, char > UsersTraits;

    const UsersOptional&
    getUsers () const;

    UsersOptional&
    getUsers ();

    void
    setUsers (const UsersType& x);

    void
    setUsers (const UsersOptional& x);

    void
    setUsers (::std::unique_ptr< UsersType > p);

    // sidebars-by-ref
    //
    typedef ::conference_info::Uris_type Sidebars_by_refType;
    typedef ::xsd::cxx::tree::optional< Sidebars_by_refType > Sidebars_by_refOptional;
    typedef ::xsd::cxx::tree::traits< Sidebars_by_refType, char > Sidebars_by_refTraits;

    const Sidebars_by_refOptional&
    getSidebars_by_ref () const;

    Sidebars_by_refOptional&
    getSidebars_by_ref ();

    void
    setSidebars_by_ref (const Sidebars_by_refType& x);

    void
    setSidebars_by_ref (const Sidebars_by_refOptional& x);

    void
    setSidebars_by_ref (::std::unique_ptr< Sidebars_by_refType > p);

    // sidebars-by-val
    //
    typedef ::conference_info::Sidebars_by_val_type Sidebars_by_valType;
    typedef ::xsd::cxx::tree::optional< Sidebars_by_valType > Sidebars_by_valOptional;
    typedef ::xsd::cxx::tree::traits< Sidebars_by_valType, char > Sidebars_by_valTraits;

    const Sidebars_by_valOptional&
    getSidebars_by_val () const;

    Sidebars_by_valOptional&
    getSidebars_by_val ();

    void
    setSidebars_by_val (const Sidebars_by_valType& x);

    void
    setSidebars_by_val (const Sidebars_by_valOptional& x);

    void
    setSidebars_by_val (::std::unique_ptr< Sidebars_by_valType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // entity
    //
    typedef ::xml_schema::Uri EntityType;
    typedef ::xsd::cxx::tree::traits< EntityType, char > EntityTraits;

    const EntityType&
    getEntity () const;

    EntityType&
    getEntity ();

    void
    setEntity (const EntityType& x);

    void
    setEntity (::std::unique_ptr< EntityType > p);

    ::std::unique_ptr< EntityType >
    detachEntity ();

    // state
    //
    typedef ::conference_info::State_type StateType;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateType&
    getState () const;

    StateType&
    getState ();

    void
    setState (const StateType& x);

    void
    setState (::std::unique_ptr< StateType > p);

    ::std::unique_ptr< StateType >
    detachState ();

    static const StateType&
    getStateDefaultValue ();

    // version
    //
    typedef ::xml_schema::UnsignedInt VersionType;
    typedef ::xsd::cxx::tree::optional< VersionType > VersionOptional;
    typedef ::xsd::cxx::tree::traits< VersionType, char > VersionTraits;

    const VersionOptional&
    getVersion () const;

    VersionOptional&
    getVersion ();

    void
    setVersion (const VersionType& x);

    void
    setVersion (const VersionOptional& x);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Conference_type (const EntityType&);

    Conference_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    Conference_type (const Conference_type& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual Conference_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Conference_type&
    operator= (const Conference_type& x);

    virtual 
    ~Conference_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    Conference_descriptionOptional conference_description_;
    Host_infoOptional host_info_;
    Conference_stateOptional conference_state_;
    UsersOptional users_;
    Sidebars_by_refOptional sidebars_by_ref_;
    Sidebars_by_valOptional sidebars_by_val_;
    AnySequence any_;
    ::xsd::cxx::tree::one< EntityType > entity_;
    ::xsd::cxx::tree::one< StateType > state_;
    static const StateType state_default_value_;
    VersionOptional version_;
    AnyAttributeSet any_attribute_;
  };

  class State_type: public ::xml_schema::String
  {
    public:
    enum Value
    {
      full,
      partial,
      deleted
    };

    State_type (Value v);

    State_type (const char* v);

    State_type (const ::std::string& v);

    State_type (const ::xml_schema::String& v);

    State_type (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    State_type (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    State_type (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    State_type (const State_type& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual State_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    State_type&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_State_type_convert ();
    }

    protected:
    Value
    _xsd_State_type_convert () const;

    public:
    static const char* const _xsd_State_type_literals_[3];
    static const Value _xsd_State_type_indexes_[3];
  };

  class Conference_description_type: public ::xml_schema::Type
  {
    public:
    // display-text
    //
    typedef ::xml_schema::String Display_textType;
    typedef ::xsd::cxx::tree::optional< Display_textType > Display_textOptional;
    typedef ::xsd::cxx::tree::traits< Display_textType, char > Display_textTraits;

    const Display_textOptional&
    getDisplay_text () const;

    Display_textOptional&
    getDisplay_text ();

    void
    setDisplay_text (const Display_textType& x);

    void
    setDisplay_text (const Display_textOptional& x);

    void
    setDisplay_text (::std::unique_ptr< Display_textType > p);

    // subject
    //
    typedef ::xml_schema::String SubjectType;
    typedef ::xsd::cxx::tree::optional< SubjectType > SubjectOptional;
    typedef ::xsd::cxx::tree::traits< SubjectType, char > SubjectTraits;

    const SubjectOptional&
    getSubject () const;

    SubjectOptional&
    getSubject ();

    void
    setSubject (const SubjectType& x);

    void
    setSubject (const SubjectOptional& x);

    void
    setSubject (::std::unique_ptr< SubjectType > p);

    // free-text
    //
    typedef ::xml_schema::String Free_textType;
    typedef ::xsd::cxx::tree::optional< Free_textType > Free_textOptional;
    typedef ::xsd::cxx::tree::traits< Free_textType, char > Free_textTraits;

    const Free_textOptional&
    getFree_text () const;

    Free_textOptional&
    getFree_text ();

    void
    setFree_text (const Free_textType& x);

    void
    setFree_text (const Free_textOptional& x);

    void
    setFree_text (::std::unique_ptr< Free_textType > p);

    // keywords
    //
    typedef ::conference_info::Keywords_type KeywordsType;
    typedef ::xsd::cxx::tree::optional< KeywordsType > KeywordsOptional;
    typedef ::xsd::cxx::tree::traits< KeywordsType, char > KeywordsTraits;

    const KeywordsOptional&
    getKeywords () const;

    KeywordsOptional&
    getKeywords ();

    void
    setKeywords (const KeywordsType& x);

    void
    setKeywords (const KeywordsOptional& x);

    void
    setKeywords (::std::unique_ptr< KeywordsType > p);

    // conf-uris
    //
    typedef ::conference_info::Uris_type Conf_urisType;
    typedef ::xsd::cxx::tree::optional< Conf_urisType > Conf_urisOptional;
    typedef ::xsd::cxx::tree::traits< Conf_urisType, char > Conf_urisTraits;

    const Conf_urisOptional&
    getConf_uris () const;

    Conf_urisOptional&
    getConf_uris ();

    void
    setConf_uris (const Conf_urisType& x);

    void
    setConf_uris (const Conf_urisOptional& x);

    void
    setConf_uris (::std::unique_ptr< Conf_urisType > p);

    // service-uris
    //
    typedef ::conference_info::Uris_type Service_urisType;
    typedef ::xsd::cxx::tree::optional< Service_urisType > Service_urisOptional;
    typedef ::xsd::cxx::tree::traits< Service_urisType, char > Service_urisTraits;

    const Service_urisOptional&
    getService_uris () const;

    Service_urisOptional&
    getService_uris ();

    void
    setService_uris (const Service_urisType& x);

    void
    setService_uris (const Service_urisOptional& x);

    void
    setService_uris (::std::unique_ptr< Service_urisType > p);

    // maximum-user-count
    //
    typedef ::xml_schema::UnsignedInt Maximum_user_countType;
    typedef ::xsd::cxx::tree::optional< Maximum_user_countType > Maximum_user_countOptional;
    typedef ::xsd::cxx::tree::traits< Maximum_user_countType, char > Maximum_user_countTraits;

    const Maximum_user_countOptional&
    getMaximum_user_count () const;

    Maximum_user_countOptional&
    getMaximum_user_count ();

    void
    setMaximum_user_count (const Maximum_user_countType& x);

    void
    setMaximum_user_count (const Maximum_user_countOptional& x);

    // available-media
    //
    typedef ::conference_info::Conference_media_type Available_mediaType;
    typedef ::xsd::cxx::tree::optional< Available_mediaType > Available_mediaOptional;
    typedef ::xsd::cxx::tree::traits< Available_mediaType, char > Available_mediaTraits;

    const Available_mediaOptional&
    getAvailable_media () const;

    Available_mediaOptional&
    getAvailable_media ();

    void
    setAvailable_media (const Available_mediaType& x);

    void
    setAvailable_media (const Available_mediaOptional& x);

    void
    setAvailable_media (::std::unique_ptr< Available_mediaType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Conference_description_type ();

    Conference_description_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    Conference_description_type (const Conference_description_type& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual Conference_description_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Conference_description_type&
    operator= (const Conference_description_type& x);

    virtual 
    ~Conference_description_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    Display_textOptional display_text_;
    SubjectOptional subject_;
    Free_textOptional free_text_;
    KeywordsOptional keywords_;
    Conf_urisOptional conf_uris_;
    Service_urisOptional service_uris_;
    Maximum_user_countOptional maximum_user_count_;
    Available_mediaOptional available_media_;
    AnySequence any_;
    AnyAttributeSet any_attribute_;
  };

  class Host_type: public ::xml_schema::Type
  {
    public:
    // display-text
    //
    typedef ::xml_schema::String Display_textType;
    typedef ::xsd::cxx::tree::optional< Display_textType > Display_textOptional;
    typedef ::xsd::cxx::tree::traits< Display_textType, char > Display_textTraits;

    const Display_textOptional&
    getDisplay_text () const;

    Display_textOptional&
    getDisplay_text ();

    void
    setDisplay_text (const Display_textType& x);

    void
    setDisplay_text (const Display_textOptional& x);

    void
    setDisplay_text (::std::unique_ptr< Display_textType > p);

    // web-page
    //
    typedef ::xml_schema::Uri Web_pageType;
    typedef ::xsd::cxx::tree::optional< Web_pageType > Web_pageOptional;
    typedef ::xsd::cxx::tree::traits< Web_pageType, char > Web_pageTraits;

    const Web_pageOptional&
    getWeb_page () const;

    Web_pageOptional&
    getWeb_page ();

    void
    setWeb_page (const Web_pageType& x);

    void
    setWeb_page (const Web_pageOptional& x);

    void
    setWeb_page (::std::unique_ptr< Web_pageType > p);

    // uris
    //
    typedef ::conference_info::Uris_type UrisType;
    typedef ::xsd::cxx::tree::optional< UrisType > UrisOptional;
    typedef ::xsd::cxx::tree::traits< UrisType, char > UrisTraits;

    const UrisOptional&
    getUris () const;

    UrisOptional&
    getUris ();

    void
    setUris (const UrisType& x);

    void
    setUris (const UrisOptional& x);

    void
    setUris (::std::unique_ptr< UrisType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Host_type ();

    Host_type (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Host_type (const Host_type& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual Host_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Host_type&
    operator= (const Host_type& x);

    virtual 
    ~Host_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    Display_textOptional display_text_;
    Web_pageOptional web_page_;
    UrisOptional uris_;
    AnySequence any_;
    AnyAttributeSet any_attribute_;
  };

  class Conference_state_type: public ::xml_schema::Type
  {
    public:
    // user-count
    //
    typedef ::xml_schema::UnsignedInt User_countType;
    typedef ::xsd::cxx::tree::optional< User_countType > User_countOptional;
    typedef ::xsd::cxx::tree::traits< User_countType, char > User_countTraits;

    const User_countOptional&
    getUser_count () const;

    User_countOptional&
    getUser_count ();

    void
    setUser_count (const User_countType& x);

    void
    setUser_count (const User_countOptional& x);

    // active
    //
    typedef ::xml_schema::Boolean ActiveType;
    typedef ::xsd::cxx::tree::optional< ActiveType > ActiveOptional;
    typedef ::xsd::cxx::tree::traits< ActiveType, char > ActiveTraits;

    const ActiveOptional&
    getActive () const;

    ActiveOptional&
    getActive ();

    void
    setActive (const ActiveType& x);

    void
    setActive (const ActiveOptional& x);

    // locked
    //
    typedef ::xml_schema::Boolean LockedType;
    typedef ::xsd::cxx::tree::optional< LockedType > LockedOptional;
    typedef ::xsd::cxx::tree::traits< LockedType, char > LockedTraits;

    const LockedOptional&
    getLocked () const;

    LockedOptional&
    getLocked ();

    void
    setLocked (const LockedType& x);

    void
    setLocked (const LockedOptional& x);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Conference_state_type ();

    Conference_state_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    Conference_state_type (const Conference_state_type& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual Conference_state_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Conference_state_type&
    operator= (const Conference_state_type& x);

    virtual 
    ~Conference_state_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    User_countOptional user_count_;
    ActiveOptional active_;
    LockedOptional locked_;
    AnySequence any_;
    AnyAttributeSet any_attribute_;
  };

  class Conference_media_type: public ::xml_schema::Type
  {
    public:
    // entry
    //
    typedef ::conference_info::Conference_medium_type EntryType;
    typedef ::xsd::cxx::tree::sequence< EntryType > EntrySequence;
    typedef EntrySequence::iterator EntryIterator;
    typedef EntrySequence::const_iterator EntryConstIterator;
    typedef ::xsd::cxx::tree::traits< EntryType, char > EntryTraits;

    const EntrySequence&
    getEntry () const;

    EntrySequence&
    getEntry ();

    void
    setEntry (const EntrySequence& s);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Conference_media_type ();

    Conference_media_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    Conference_media_type (const Conference_media_type& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual Conference_media_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Conference_media_type&
    operator= (const Conference_media_type& x);

    virtual 
    ~Conference_media_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    EntrySequence entry_;
    AnyAttributeSet any_attribute_;
  };

  class Conference_medium_type: public ::xml_schema::Type
  {
    public:
    // display-text
    //
    typedef ::xml_schema::String Display_textType;
    typedef ::xsd::cxx::tree::optional< Display_textType > Display_textOptional;
    typedef ::xsd::cxx::tree::traits< Display_textType, char > Display_textTraits;

    const Display_textOptional&
    getDisplay_text () const;

    Display_textOptional&
    getDisplay_text ();

    void
    setDisplay_text (const Display_textType& x);

    void
    setDisplay_text (const Display_textOptional& x);

    void
    setDisplay_text (::std::unique_ptr< Display_textType > p);

    // type
    //
    typedef ::xml_schema::String TypeType;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeType&
    getType () const;

    TypeType&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    ::std::unique_ptr< TypeType >
    detachType ();

    // status
    //
    typedef ::conference_info::Media_status_type StatusType;
    typedef ::xsd::cxx::tree::optional< StatusType > StatusOptional;
    typedef ::xsd::cxx::tree::traits< StatusType, char > StatusTraits;

    const StatusOptional&
    getStatus () const;

    StatusOptional&
    getStatus ();

    void
    setStatus (const StatusType& x);

    void
    setStatus (const StatusOptional& x);

    void
    setStatus (::std::unique_ptr< StatusType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // label
    //
    typedef ::xml_schema::String LabelType;
    typedef ::xsd::cxx::tree::traits< LabelType, char > LabelTraits;

    const LabelType&
    getLabel () const;

    LabelType&
    getLabel ();

    void
    setLabel (const LabelType& x);

    void
    setLabel (::std::unique_ptr< LabelType > p);

    ::std::unique_ptr< LabelType >
    detachLabel ();

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Conference_medium_type (const TypeType&,
                            const LabelType&);

    Conference_medium_type (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    Conference_medium_type (const Conference_medium_type& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

    virtual Conference_medium_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Conference_medium_type&
    operator= (const Conference_medium_type& x);

    virtual 
    ~Conference_medium_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    Display_textOptional display_text_;
    ::xsd::cxx::tree::one< TypeType > type_;
    StatusOptional status_;
    AnySequence any_;
    ::xsd::cxx::tree::one< LabelType > label_;
    AnyAttributeSet any_attribute_;
  };

  class Uris_type: public ::xml_schema::Type
  {
    public:
    // entry
    //
    typedef ::conference_info::Uri_type EntryType;
    typedef ::xsd::cxx::tree::sequence< EntryType > EntrySequence;
    typedef EntrySequence::iterator EntryIterator;
    typedef EntrySequence::const_iterator EntryConstIterator;
    typedef ::xsd::cxx::tree::traits< EntryType, char > EntryTraits;

    const EntrySequence&
    getEntry () const;

    EntrySequence&
    getEntry ();

    void
    setEntry (const EntrySequence& s);

    // state
    //
    typedef ::conference_info::State_type StateType;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateType&
    getState () const;

    StateType&
    getState ();

    void
    setState (const StateType& x);

    void
    setState (::std::unique_ptr< StateType > p);

    ::std::unique_ptr< StateType >
    detachState ();

    static const StateType&
    getStateDefaultValue ();

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Uris_type ();

    Uris_type (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Uris_type (const Uris_type& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual Uris_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Uris_type&
    operator= (const Uris_type& x);

    virtual 
    ~Uris_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    EntrySequence entry_;
    ::xsd::cxx::tree::one< StateType > state_;
    static const StateType state_default_value_;
    AnyAttributeSet any_attribute_;
  };

  class Uri_type: public ::xml_schema::Type
  {
    public:
    // uri
    //
    typedef ::xml_schema::Uri UriType;
    typedef ::xsd::cxx::tree::traits< UriType, char > UriTraits;

    const UriType&
    getUri () const;

    UriType&
    getUri ();

    void
    setUri (const UriType& x);

    void
    setUri (::std::unique_ptr< UriType > p);

    ::std::unique_ptr< UriType >
    detachUri ();

    // display-text
    //
    typedef ::xml_schema::String Display_textType;
    typedef ::xsd::cxx::tree::optional< Display_textType > Display_textOptional;
    typedef ::xsd::cxx::tree::traits< Display_textType, char > Display_textTraits;

    const Display_textOptional&
    getDisplay_text () const;

    Display_textOptional&
    getDisplay_text ();

    void
    setDisplay_text (const Display_textType& x);

    void
    setDisplay_text (const Display_textOptional& x);

    void
    setDisplay_text (::std::unique_ptr< Display_textType > p);

    // purpose
    //
    typedef ::xml_schema::String PurposeType;
    typedef ::xsd::cxx::tree::optional< PurposeType > PurposeOptional;
    typedef ::xsd::cxx::tree::traits< PurposeType, char > PurposeTraits;

    const PurposeOptional&
    getPurpose () const;

    PurposeOptional&
    getPurpose ();

    void
    setPurpose (const PurposeType& x);

    void
    setPurpose (const PurposeOptional& x);

    void
    setPurpose (::std::unique_ptr< PurposeType > p);

    // modified
    //
    typedef ::conference_info::Execution_type ModifiedType;
    typedef ::xsd::cxx::tree::optional< ModifiedType > ModifiedOptional;
    typedef ::xsd::cxx::tree::traits< ModifiedType, char > ModifiedTraits;

    const ModifiedOptional&
    getModified () const;

    ModifiedOptional&
    getModified ();

    void
    setModified (const ModifiedType& x);

    void
    setModified (const ModifiedOptional& x);

    void
    setModified (::std::unique_ptr< ModifiedType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Uri_type (const UriType&);

    Uri_type (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    Uri_type (const Uri_type& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual Uri_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Uri_type&
    operator= (const Uri_type& x);

    virtual 
    ~Uri_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    ::xsd::cxx::tree::one< UriType > uri_;
    Display_textOptional display_text_;
    PurposeOptional purpose_;
    ModifiedOptional modified_;
    AnySequence any_;
    AnyAttributeSet any_attribute_;
  };

  class Keywords_type: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::xml_schema::String, char >
  {
    public:
    Keywords_type ();

    Keywords_type (size_type n, const ::xml_schema::String& x);

    template < typename I >
    Keywords_type (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::String, char > (begin, end, this)
    {
    }

    Keywords_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    Keywords_type (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    Keywords_type (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    Keywords_type (const Keywords_type& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual Keywords_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~Keywords_type ();
  };

  class Users_type: public ::xml_schema::Type
  {
    public:
    // user
    //
    typedef ::conference_info::User_type UserType;
    typedef ::xsd::cxx::tree::sequence< UserType > UserSequence;
    typedef UserSequence::iterator UserIterator;
    typedef UserSequence::const_iterator UserConstIterator;
    typedef ::xsd::cxx::tree::traits< UserType, char > UserTraits;

    const UserSequence&
    getUser () const;

    UserSequence&
    getUser ();

    void
    setUser (const UserSequence& s);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // state
    //
    typedef ::conference_info::State_type StateType;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateType&
    getState () const;

    StateType&
    getState ();

    void
    setState (const StateType& x);

    void
    setState (::std::unique_ptr< StateType > p);

    ::std::unique_ptr< StateType >
    detachState ();

    static const StateType&
    getStateDefaultValue ();

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Users_type ();

    Users_type (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    Users_type (const Users_type& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual Users_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Users_type&
    operator= (const Users_type& x);

    virtual 
    ~Users_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    UserSequence user_;
    AnySequence any_;
    ::xsd::cxx::tree::one< StateType > state_;
    static const StateType state_default_value_;
    AnyAttributeSet any_attribute_;
  };

  class User_type: public ::xml_schema::Type
  {
    public:
    // display-text
    //
    typedef ::xml_schema::String Display_textType;
    typedef ::xsd::cxx::tree::optional< Display_textType > Display_textOptional;
    typedef ::xsd::cxx::tree::traits< Display_textType, char > Display_textTraits;

    const Display_textOptional&
    getDisplay_text () const;

    Display_textOptional&
    getDisplay_text ();

    void
    setDisplay_text (const Display_textType& x);

    void
    setDisplay_text (const Display_textOptional& x);

    void
    setDisplay_text (::std::unique_ptr< Display_textType > p);

    // associated-aors
    //
    typedef ::conference_info::Uris_type Associated_aorsType;
    typedef ::xsd::cxx::tree::optional< Associated_aorsType > Associated_aorsOptional;
    typedef ::xsd::cxx::tree::traits< Associated_aorsType, char > Associated_aorsTraits;

    const Associated_aorsOptional&
    getAssociated_aors () const;

    Associated_aorsOptional&
    getAssociated_aors ();

    void
    setAssociated_aors (const Associated_aorsType& x);

    void
    setAssociated_aors (const Associated_aorsOptional& x);

    void
    setAssociated_aors (::std::unique_ptr< Associated_aorsType > p);

    // roles
    //
    typedef ::conference_info::User_roles_type RolesType;
    typedef ::xsd::cxx::tree::optional< RolesType > RolesOptional;
    typedef ::xsd::cxx::tree::traits< RolesType, char > RolesTraits;

    const RolesOptional&
    getRoles () const;

    RolesOptional&
    getRoles ();

    void
    setRoles (const RolesType& x);

    void
    setRoles (const RolesOptional& x);

    void
    setRoles (::std::unique_ptr< RolesType > p);

    // languages
    //
    typedef ::conference_info::User_languages_type LanguagesType;
    typedef ::xsd::cxx::tree::optional< LanguagesType > LanguagesOptional;
    typedef ::xsd::cxx::tree::traits< LanguagesType, char > LanguagesTraits;

    const LanguagesOptional&
    getLanguages () const;

    LanguagesOptional&
    getLanguages ();

    void
    setLanguages (const LanguagesType& x);

    void
    setLanguages (const LanguagesOptional& x);

    void
    setLanguages (::std::unique_ptr< LanguagesType > p);

    // cascaded-focus
    //
    typedef ::xml_schema::Uri Cascaded_focusType;
    typedef ::xsd::cxx::tree::optional< Cascaded_focusType > Cascaded_focusOptional;
    typedef ::xsd::cxx::tree::traits< Cascaded_focusType, char > Cascaded_focusTraits;

    const Cascaded_focusOptional&
    getCascaded_focus () const;

    Cascaded_focusOptional&
    getCascaded_focus ();

    void
    setCascaded_focus (const Cascaded_focusType& x);

    void
    setCascaded_focus (const Cascaded_focusOptional& x);

    void
    setCascaded_focus (::std::unique_ptr< Cascaded_focusType > p);

    // endpoint
    //
    typedef ::conference_info::Endpoint_type EndpointType;
    typedef ::xsd::cxx::tree::sequence< EndpointType > EndpointSequence;
    typedef EndpointSequence::iterator EndpointIterator;
    typedef EndpointSequence::const_iterator EndpointConstIterator;
    typedef ::xsd::cxx::tree::traits< EndpointType, char > EndpointTraits;

    const EndpointSequence&
    getEndpoint () const;

    EndpointSequence&
    getEndpoint ();

    void
    setEndpoint (const EndpointSequence& s);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // entity
    //
    typedef ::xml_schema::Uri EntityType;
    typedef ::xsd::cxx::tree::optional< EntityType > EntityOptional;
    typedef ::xsd::cxx::tree::traits< EntityType, char > EntityTraits;

    const EntityOptional&
    getEntity () const;

    EntityOptional&
    getEntity ();

    void
    setEntity (const EntityType& x);

    void
    setEntity (const EntityOptional& x);

    void
    setEntity (::std::unique_ptr< EntityType > p);

    // state
    //
    typedef ::conference_info::State_type StateType;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateType&
    getState () const;

    StateType&
    getState ();

    void
    setState (const StateType& x);

    void
    setState (::std::unique_ptr< StateType > p);

    ::std::unique_ptr< StateType >
    detachState ();

    static const StateType&
    getStateDefaultValue ();

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    User_type ();

    User_type (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    User_type (const User_type& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual User_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    User_type&
    operator= (const User_type& x);

    virtual 
    ~User_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    Display_textOptional display_text_;
    Associated_aorsOptional associated_aors_;
    RolesOptional roles_;
    LanguagesOptional languages_;
    Cascaded_focusOptional cascaded_focus_;
    EndpointSequence endpoint_;
    AnySequence any_;
    EntityOptional entity_;
    ::xsd::cxx::tree::one< StateType > state_;
    static const StateType state_default_value_;
    AnyAttributeSet any_attribute_;
  };

  class User_roles_type: public ::xml_schema::Type
  {
    public:
    // entry
    //
    typedef ::xml_schema::String EntryType;
    typedef ::xsd::cxx::tree::sequence< EntryType > EntrySequence;
    typedef EntrySequence::iterator EntryIterator;
    typedef EntrySequence::const_iterator EntryConstIterator;
    typedef ::xsd::cxx::tree::traits< EntryType, char > EntryTraits;

    const EntrySequence&
    getEntry () const;

    EntrySequence&
    getEntry ();

    void
    setEntry (const EntrySequence& s);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    User_roles_type ();

    User_roles_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    User_roles_type (const User_roles_type& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual User_roles_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    User_roles_type&
    operator= (const User_roles_type& x);

    virtual 
    ~User_roles_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    EntrySequence entry_;
    AnyAttributeSet any_attribute_;
  };

  class User_languages_type: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::xml_schema::Language, char >
  {
    public:
    User_languages_type ();

    User_languages_type (size_type n, const ::xml_schema::Language& x);

    template < typename I >
    User_languages_type (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::Language, char > (begin, end, this)
    {
    }

    User_languages_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    User_languages_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    User_languages_type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    User_languages_type (const User_languages_type& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual User_languages_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~User_languages_type ();
  };

  class Endpoint_type: public ::xml_schema::Type
  {
    public:
    // display-text
    //
    typedef ::xml_schema::String Display_textType;
    typedef ::xsd::cxx::tree::optional< Display_textType > Display_textOptional;
    typedef ::xsd::cxx::tree::traits< Display_textType, char > Display_textTraits;

    const Display_textOptional&
    getDisplay_text () const;

    Display_textOptional&
    getDisplay_text ();

    void
    setDisplay_text (const Display_textType& x);

    void
    setDisplay_text (const Display_textOptional& x);

    void
    setDisplay_text (::std::unique_ptr< Display_textType > p);

    // referred
    //
    typedef ::conference_info::Execution_type ReferredType;
    typedef ::xsd::cxx::tree::optional< ReferredType > ReferredOptional;
    typedef ::xsd::cxx::tree::traits< ReferredType, char > ReferredTraits;

    const ReferredOptional&
    getReferred () const;

    ReferredOptional&
    getReferred ();

    void
    setReferred (const ReferredType& x);

    void
    setReferred (const ReferredOptional& x);

    void
    setReferred (::std::unique_ptr< ReferredType > p);

    // status
    //
    typedef ::conference_info::Endpoint_status_type StatusType;
    typedef ::xsd::cxx::tree::optional< StatusType > StatusOptional;
    typedef ::xsd::cxx::tree::traits< StatusType, char > StatusTraits;

    const StatusOptional&
    getStatus () const;

    StatusOptional&
    getStatus ();

    void
    setStatus (const StatusType& x);

    void
    setStatus (const StatusOptional& x);

    void
    setStatus (::std::unique_ptr< StatusType > p);

    // joining-method
    //
    typedef ::conference_info::Joining_type Joining_methodType;
    typedef ::xsd::cxx::tree::optional< Joining_methodType > Joining_methodOptional;
    typedef ::xsd::cxx::tree::traits< Joining_methodType, char > Joining_methodTraits;

    const Joining_methodOptional&
    getJoining_method () const;

    Joining_methodOptional&
    getJoining_method ();

    void
    setJoining_method (const Joining_methodType& x);

    void
    setJoining_method (const Joining_methodOptional& x);

    void
    setJoining_method (::std::unique_ptr< Joining_methodType > p);

    // joining-info
    //
    typedef ::conference_info::Execution_type Joining_infoType;
    typedef ::xsd::cxx::tree::optional< Joining_infoType > Joining_infoOptional;
    typedef ::xsd::cxx::tree::traits< Joining_infoType, char > Joining_infoTraits;

    const Joining_infoOptional&
    getJoining_info () const;

    Joining_infoOptional&
    getJoining_info ();

    void
    setJoining_info (const Joining_infoType& x);

    void
    setJoining_info (const Joining_infoOptional& x);

    void
    setJoining_info (::std::unique_ptr< Joining_infoType > p);

    // disconnection-method
    //
    typedef ::conference_info::Disconnection_type Disconnection_methodType;
    typedef ::xsd::cxx::tree::optional< Disconnection_methodType > Disconnection_methodOptional;
    typedef ::xsd::cxx::tree::traits< Disconnection_methodType, char > Disconnection_methodTraits;

    const Disconnection_methodOptional&
    getDisconnection_method () const;

    Disconnection_methodOptional&
    getDisconnection_method ();

    void
    setDisconnection_method (const Disconnection_methodType& x);

    void
    setDisconnection_method (const Disconnection_methodOptional& x);

    void
    setDisconnection_method (::std::unique_ptr< Disconnection_methodType > p);

    // disconnection-info
    //
    typedef ::conference_info::Execution_type Disconnection_infoType;
    typedef ::xsd::cxx::tree::optional< Disconnection_infoType > Disconnection_infoOptional;
    typedef ::xsd::cxx::tree::traits< Disconnection_infoType, char > Disconnection_infoTraits;

    const Disconnection_infoOptional&
    getDisconnection_info () const;

    Disconnection_infoOptional&
    getDisconnection_info ();

    void
    setDisconnection_info (const Disconnection_infoType& x);

    void
    setDisconnection_info (const Disconnection_infoOptional& x);

    void
    setDisconnection_info (::std::unique_ptr< Disconnection_infoType > p);

    // media
    //
    typedef ::conference_info::Media_type MediaType;
    typedef ::xsd::cxx::tree::sequence< MediaType > MediaSequence;
    typedef MediaSequence::iterator MediaIterator;
    typedef MediaSequence::const_iterator MediaConstIterator;
    typedef ::xsd::cxx::tree::traits< MediaType, char > MediaTraits;

    const MediaSequence&
    getMedia () const;

    MediaSequence&
    getMedia ();

    void
    setMedia (const MediaSequence& s);

    // call-info
    //
    typedef ::conference_info::Call_type Call_infoType;
    typedef ::xsd::cxx::tree::optional< Call_infoType > Call_infoOptional;
    typedef ::xsd::cxx::tree::traits< Call_infoType, char > Call_infoTraits;

    const Call_infoOptional&
    getCall_info () const;

    Call_infoOptional&
    getCall_info ();

    void
    setCall_info (const Call_infoType& x);

    void
    setCall_info (const Call_infoOptional& x);

    void
    setCall_info (::std::unique_ptr< Call_infoType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // entity
    //
    typedef ::xml_schema::String EntityType;
    typedef ::xsd::cxx::tree::optional< EntityType > EntityOptional;
    typedef ::xsd::cxx::tree::traits< EntityType, char > EntityTraits;

    const EntityOptional&
    getEntity () const;

    EntityOptional&
    getEntity ();

    void
    setEntity (const EntityType& x);

    void
    setEntity (const EntityOptional& x);

    void
    setEntity (::std::unique_ptr< EntityType > p);

    // state
    //
    typedef ::conference_info::State_type StateType;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateType&
    getState () const;

    StateType&
    getState ();

    void
    setState (const StateType& x);

    void
    setState (::std::unique_ptr< StateType > p);

    ::std::unique_ptr< StateType >
    detachState ();

    static const StateType&
    getStateDefaultValue ();

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Endpoint_type ();

    Endpoint_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    Endpoint_type (const Endpoint_type& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual Endpoint_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Endpoint_type&
    operator= (const Endpoint_type& x);

    virtual 
    ~Endpoint_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    Display_textOptional display_text_;
    ReferredOptional referred_;
    StatusOptional status_;
    Joining_methodOptional joining_method_;
    Joining_infoOptional joining_info_;
    Disconnection_methodOptional disconnection_method_;
    Disconnection_infoOptional disconnection_info_;
    MediaSequence media_;
    Call_infoOptional call_info_;
    AnySequence any_;
    EntityOptional entity_;
    ::xsd::cxx::tree::one< StateType > state_;
    static const StateType state_default_value_;
    AnyAttributeSet any_attribute_;
  };

  class Endpoint_status_type: public ::xml_schema::String
  {
    public:
    enum Value
    {
      pending,
      dialing_out,
      dialing_in,
      alerting,
      on_hold,
      connected,
      muted_via_focus,
      disconnecting,
      disconnected
    };

    Endpoint_status_type (Value v);

    Endpoint_status_type (const char* v);

    Endpoint_status_type (const ::std::string& v);

    Endpoint_status_type (const ::xml_schema::String& v);

    Endpoint_status_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    Endpoint_status_type (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    Endpoint_status_type (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    Endpoint_status_type (const Endpoint_status_type& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual Endpoint_status_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Endpoint_status_type&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_Endpoint_status_type_convert ();
    }

    protected:
    Value
    _xsd_Endpoint_status_type_convert () const;

    public:
    static const char* const _xsd_Endpoint_status_type_literals_[9];
    static const Value _xsd_Endpoint_status_type_indexes_[9];
  };

  class Joining_type: public ::xml_schema::String
  {
    public:
    enum Value
    {
      dialed_in,
      dialed_out,
      focus_owner
    };

    Joining_type (Value v);

    Joining_type (const char* v);

    Joining_type (const ::std::string& v);

    Joining_type (const ::xml_schema::String& v);

    Joining_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    Joining_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    Joining_type (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    Joining_type (const Joining_type& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual Joining_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Joining_type&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_Joining_type_convert ();
    }

    protected:
    Value
    _xsd_Joining_type_convert () const;

    public:
    static const char* const _xsd_Joining_type_literals_[3];
    static const Value _xsd_Joining_type_indexes_[3];
  };

  class Disconnection_type: public ::xml_schema::String
  {
    public:
    enum Value
    {
      departed,
      booted,
      failed,
      busy
    };

    Disconnection_type (Value v);

    Disconnection_type (const char* v);

    Disconnection_type (const ::std::string& v);

    Disconnection_type (const ::xml_schema::String& v);

    Disconnection_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    Disconnection_type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    Disconnection_type (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    Disconnection_type (const Disconnection_type& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual Disconnection_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Disconnection_type&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_Disconnection_type_convert ();
    }

    protected:
    Value
    _xsd_Disconnection_type_convert () const;

    public:
    static const char* const _xsd_Disconnection_type_literals_[4];
    static const Value _xsd_Disconnection_type_indexes_[4];
  };

  class Execution_type: public ::xml_schema::Type
  {
    public:
    // when
    //
    typedef ::xml_schema::DateTime WhenType;
    typedef ::xsd::cxx::tree::optional< WhenType > WhenOptional;
    typedef ::xsd::cxx::tree::traits< WhenType, char > WhenTraits;

    const WhenOptional&
    getWhen () const;

    WhenOptional&
    getWhen ();

    void
    setWhen (const WhenType& x);

    void
    setWhen (const WhenOptional& x);

    void
    setWhen (::std::unique_ptr< WhenType > p);

    // reason
    //
    typedef ::xml_schema::String ReasonType;
    typedef ::xsd::cxx::tree::optional< ReasonType > ReasonOptional;
    typedef ::xsd::cxx::tree::traits< ReasonType, char > ReasonTraits;

    const ReasonOptional&
    getReason () const;

    ReasonOptional&
    getReason ();

    void
    setReason (const ReasonType& x);

    void
    setReason (const ReasonOptional& x);

    void
    setReason (::std::unique_ptr< ReasonType > p);

    // by
    //
    typedef ::xml_schema::Uri ByType;
    typedef ::xsd::cxx::tree::optional< ByType > ByOptional;
    typedef ::xsd::cxx::tree::traits< ByType, char > ByTraits;

    const ByOptional&
    getBy () const;

    ByOptional&
    getBy ();

    void
    setBy (const ByType& x);

    void
    setBy (const ByOptional& x);

    void
    setBy (::std::unique_ptr< ByType > p);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Execution_type ();

    Execution_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    Execution_type (const Execution_type& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual Execution_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Execution_type&
    operator= (const Execution_type& x);

    virtual 
    ~Execution_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    WhenOptional when_;
    ReasonOptional reason_;
    ByOptional by_;
    AnyAttributeSet any_attribute_;
  };

  class Call_type: public ::xml_schema::Type
  {
    public:
    // sip
    //
    typedef ::conference_info::Sip_dialog_id_type SipType;
    typedef ::xsd::cxx::tree::optional< SipType > SipOptional;
    typedef ::xsd::cxx::tree::traits< SipType, char > SipTraits;

    const SipOptional&
    getSip () const;

    SipOptional&
    getSip ();

    void
    setSip (const SipType& x);

    void
    setSip (const SipOptional& x);

    void
    setSip (::std::unique_ptr< SipType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Call_type ();

    Call_type (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    Call_type (const Call_type& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    virtual Call_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Call_type&
    operator= (const Call_type& x);

    virtual 
    ~Call_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    SipOptional sip_;
    AnySequence any_;
    AnyAttributeSet any_attribute_;
  };

  class Sip_dialog_id_type: public ::xml_schema::Type
  {
    public:
    // display-text
    //
    typedef ::xml_schema::String Display_textType;
    typedef ::xsd::cxx::tree::optional< Display_textType > Display_textOptional;
    typedef ::xsd::cxx::tree::traits< Display_textType, char > Display_textTraits;

    const Display_textOptional&
    getDisplay_text () const;

    Display_textOptional&
    getDisplay_text ();

    void
    setDisplay_text (const Display_textType& x);

    void
    setDisplay_text (const Display_textOptional& x);

    void
    setDisplay_text (::std::unique_ptr< Display_textType > p);

    // call-id
    //
    typedef ::xml_schema::String Call_idType;
    typedef ::xsd::cxx::tree::traits< Call_idType, char > Call_idTraits;

    const Call_idType&
    getCall_id () const;

    Call_idType&
    getCall_id ();

    void
    setCall_id (const Call_idType& x);

    void
    setCall_id (::std::unique_ptr< Call_idType > p);

    ::std::unique_ptr< Call_idType >
    detachCall_id ();

    // from-tag
    //
    typedef ::xml_schema::String From_tagType;
    typedef ::xsd::cxx::tree::traits< From_tagType, char > From_tagTraits;

    const From_tagType&
    getFrom_tag () const;

    From_tagType&
    getFrom_tag ();

    void
    setFrom_tag (const From_tagType& x);

    void
    setFrom_tag (::std::unique_ptr< From_tagType > p);

    ::std::unique_ptr< From_tagType >
    detachFrom_tag ();

    // to-tag
    //
    typedef ::xml_schema::String To_tagType;
    typedef ::xsd::cxx::tree::traits< To_tagType, char > To_tagTraits;

    const To_tagType&
    getTo_tag () const;

    To_tagType&
    getTo_tag ();

    void
    setTo_tag (const To_tagType& x);

    void
    setTo_tag (::std::unique_ptr< To_tagType > p);

    ::std::unique_ptr< To_tagType >
    detachTo_tag ();

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Sip_dialog_id_type (const Call_idType&,
                        const From_tagType&,
                        const To_tagType&);

    Sip_dialog_id_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    Sip_dialog_id_type (const Sip_dialog_id_type& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual Sip_dialog_id_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Sip_dialog_id_type&
    operator= (const Sip_dialog_id_type& x);

    virtual 
    ~Sip_dialog_id_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    Display_textOptional display_text_;
    ::xsd::cxx::tree::one< Call_idType > call_id_;
    ::xsd::cxx::tree::one< From_tagType > from_tag_;
    ::xsd::cxx::tree::one< To_tagType > to_tag_;
    AnySequence any_;
    AnyAttributeSet any_attribute_;
  };

  class Media_type: public ::xml_schema::Type
  {
    public:
    // display-text
    //
    typedef ::xml_schema::String Display_textType;
    typedef ::xsd::cxx::tree::optional< Display_textType > Display_textOptional;
    typedef ::xsd::cxx::tree::traits< Display_textType, char > Display_textTraits;

    const Display_textOptional&
    getDisplay_text () const;

    Display_textOptional&
    getDisplay_text ();

    void
    setDisplay_text (const Display_textType& x);

    void
    setDisplay_text (const Display_textOptional& x);

    void
    setDisplay_text (::std::unique_ptr< Display_textType > p);

    // type
    //
    typedef ::xml_schema::String TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    getType () const;

    TypeOptional&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (const TypeOptional& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // label
    //
    typedef ::xml_schema::String LabelType;
    typedef ::xsd::cxx::tree::optional< LabelType > LabelOptional;
    typedef ::xsd::cxx::tree::traits< LabelType, char > LabelTraits;

    const LabelOptional&
    getLabel () const;

    LabelOptional&
    getLabel ();

    void
    setLabel (const LabelType& x);

    void
    setLabel (const LabelOptional& x);

    void
    setLabel (::std::unique_ptr< LabelType > p);

    // src-id
    //
    typedef ::xml_schema::String Src_idType;
    typedef ::xsd::cxx::tree::optional< Src_idType > Src_idOptional;
    typedef ::xsd::cxx::tree::traits< Src_idType, char > Src_idTraits;

    const Src_idOptional&
    getSrc_id () const;

    Src_idOptional&
    getSrc_id ();

    void
    setSrc_id (const Src_idType& x);

    void
    setSrc_id (const Src_idOptional& x);

    void
    setSrc_id (::std::unique_ptr< Src_idType > p);

    // status
    //
    typedef ::conference_info::Media_status_type StatusType;
    typedef ::xsd::cxx::tree::optional< StatusType > StatusOptional;
    typedef ::xsd::cxx::tree::traits< StatusType, char > StatusTraits;

    const StatusOptional&
    getStatus () const;

    StatusOptional&
    getStatus ();

    void
    setStatus (const StatusType& x);

    void
    setStatus (const StatusOptional& x);

    void
    setStatus (::std::unique_ptr< StatusType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // id
    //
    typedef ::xml_schema::String IdType;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdType&
    getId () const;

    IdType&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (::std::unique_ptr< IdType > p);

    ::std::unique_ptr< IdType >
    detachId ();

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Media_type (const IdType&);

    Media_type (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    Media_type (const Media_type& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual Media_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Media_type&
    operator= (const Media_type& x);

    virtual 
    ~Media_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    Display_textOptional display_text_;
    TypeOptional type_;
    LabelOptional label_;
    Src_idOptional src_id_;
    StatusOptional status_;
    AnySequence any_;
    ::xsd::cxx::tree::one< IdType > id_;
    AnyAttributeSet any_attribute_;
  };

  class Media_status_type: public ::xml_schema::String
  {
    public:
    enum Value
    {
      recvonly,
      sendonly,
      sendrecv,
      inactive
    };

    Media_status_type (Value v);

    Media_status_type (const char* v);

    Media_status_type (const ::std::string& v);

    Media_status_type (const ::xml_schema::String& v);

    Media_status_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    Media_status_type (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    Media_status_type (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    Media_status_type (const Media_status_type& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual Media_status_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Media_status_type&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_Media_status_type_convert ();
    }

    protected:
    Value
    _xsd_Media_status_type_convert () const;

    public:
    static const char* const _xsd_Media_status_type_literals_[4];
    static const Value _xsd_Media_status_type_indexes_[4];
  };

  class Sidebars_by_val_type: public ::xml_schema::Type
  {
    public:
    // entry
    //
    typedef ::conference_info::Conference_type EntryType;
    typedef ::xsd::cxx::tree::sequence< EntryType > EntrySequence;
    typedef EntrySequence::iterator EntryIterator;
    typedef EntrySequence::const_iterator EntryConstIterator;
    typedef ::xsd::cxx::tree::traits< EntryType, char > EntryTraits;

    const EntrySequence&
    getEntry () const;

    EntrySequence&
    getEntry ();

    void
    setEntry (const EntrySequence& s);

    // state
    //
    typedef ::conference_info::State_type StateType;
    typedef ::xsd::cxx::tree::traits< StateType, char > StateTraits;

    const StateType&
    getState () const;

    StateType&
    getState ();

    void
    setState (const StateType& x);

    void
    setState (::std::unique_ptr< StateType > p);

    ::std::unique_ptr< StateType >
    detachState ();

    static const StateType&
    getStateDefaultValue ();

    // any_attribute
    //
    typedef ::xsd::cxx::tree::attribute_set< char > AnyAttributeSet;
    typedef AnyAttributeSet::iterator AnyAttributeIterator;
    typedef AnyAttributeSet::const_iterator AnyAttributeConstIterator;

    const AnyAttributeSet&
    getAnyAttribute () const;

    AnyAttributeSet&
    getAnyAttribute ();

    void
    setAnyAttribute (const AnyAttributeSet& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    Sidebars_by_val_type ();

    Sidebars_by_val_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    Sidebars_by_val_type (const Sidebars_by_val_type& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual Sidebars_by_val_type*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    Sidebars_by_val_type&
    operator= (const Sidebars_by_val_type& x);

    virtual 
    ~Sidebars_by_val_type ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    EntrySequence entry_;
    ::xsd::cxx::tree::one< StateType > state_;
    static const StateType state_default_value_;
    AnyAttributeSet any_attribute_;
  };
}

#include <iosfwd>

namespace conference_info
{
  ::std::ostream&
  operator<< (::std::ostream&, const Conference_type&);

  ::std::ostream&
  operator<< (::std::ostream&, State_type::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const State_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Conference_description_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Host_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Conference_state_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Conference_media_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Conference_medium_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Uris_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Uri_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Keywords_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Users_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const User_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const User_roles_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const User_languages_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Endpoint_type&);

  ::std::ostream&
  operator<< (::std::ostream&, Endpoint_status_type::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const Endpoint_status_type&);

  ::std::ostream&
  operator<< (::std::ostream&, Joining_type::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const Joining_type&);

  ::std::ostream&
  operator<< (::std::ostream&, Disconnection_type::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const Disconnection_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Execution_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Call_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Sip_dialog_id_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Media_type&);

  ::std::ostream&
  operator<< (::std::ostream&, Media_status_type::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const Media_status_type&);

  ::std::ostream&
  operator<< (::std::ostream&, const Sidebars_by_val_type&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace conference_info
{
  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (const ::std::string& uri,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (const ::std::string& uri,
                        ::xml_schema::ErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (const ::std::string& uri,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::std::istream& is,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::std::istream& is,
                        ::xml_schema::ErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::std::istream& is,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::std::istream& is,
                        const ::std::string& id,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::std::istream& is,
                        const ::std::string& id,
                        ::xml_schema::ErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::std::istream& is,
                        const ::std::string& id,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::xercesc::InputSource& is,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::xercesc::InputSource& is,
                        ::xml_schema::ErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::xercesc::InputSource& is,
                        ::xercesc::DOMErrorHandler& eh,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (const ::xercesc::DOMDocument& d,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::conference_info::Conference_type >
  parseConference_info (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                        ::xml_schema::Flags f = 0,
                        const ::xml_schema::Properties& p = ::xml_schema::Properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace conference_info
{
  // Serialize to std::ostream.
  //

  void
  serializeConference_info (::std::ostream& os,
                            const ::conference_info::Conference_type& x, 
                            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::Flags f = 0);

  void
  serializeConference_info (::std::ostream& os,
                            const ::conference_info::Conference_type& x, 
                            ::xml_schema::ErrorHandler& eh,
                            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::Flags f = 0);

  void
  serializeConference_info (::std::ostream& os,
                            const ::conference_info::Conference_type& x, 
                            ::xercesc::DOMErrorHandler& eh,
                            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  serializeConference_info (::xercesc::XMLFormatTarget& ft,
                            const ::conference_info::Conference_type& x, 
                            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::Flags f = 0);

  void
  serializeConference_info (::xercesc::XMLFormatTarget& ft,
                            const ::conference_info::Conference_type& x, 
                            ::xml_schema::ErrorHandler& eh,
                            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::Flags f = 0);

  void
  serializeConference_info (::xercesc::XMLFormatTarget& ft,
                            const ::conference_info::Conference_type& x, 
                            ::xercesc::DOMErrorHandler& eh,
                            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                            const ::std::string& e = "UTF-8",
                            ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  serializeConference_info (::xercesc::DOMDocument& d,
                            const ::conference_info::Conference_type& x,
                            ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeConference_info (const ::conference_info::Conference_type& x, 
                            const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                            ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const Conference_type&);

  void
  operator<< (::xercesc::DOMElement&, const State_type&);

  void
  operator<< (::xercesc::DOMAttr&, const State_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const State_type&);

  void
  operator<< (::xercesc::DOMElement&, const Conference_description_type&);

  void
  operator<< (::xercesc::DOMElement&, const Host_type&);

  void
  operator<< (::xercesc::DOMElement&, const Conference_state_type&);

  void
  operator<< (::xercesc::DOMElement&, const Conference_media_type&);

  void
  operator<< (::xercesc::DOMElement&, const Conference_medium_type&);

  void
  operator<< (::xercesc::DOMElement&, const Uris_type&);

  void
  operator<< (::xercesc::DOMElement&, const Uri_type&);

  void
  operator<< (::xercesc::DOMElement&, const Keywords_type&);

  void
  operator<< (::xercesc::DOMAttr&, const Keywords_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const Keywords_type&);

  void
  operator<< (::xercesc::DOMElement&, const Users_type&);

  void
  operator<< (::xercesc::DOMElement&, const User_type&);

  void
  operator<< (::xercesc::DOMElement&, const User_roles_type&);

  void
  operator<< (::xercesc::DOMElement&, const User_languages_type&);

  void
  operator<< (::xercesc::DOMAttr&, const User_languages_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const User_languages_type&);

  void
  operator<< (::xercesc::DOMElement&, const Endpoint_type&);

  void
  operator<< (::xercesc::DOMElement&, const Endpoint_status_type&);

  void
  operator<< (::xercesc::DOMAttr&, const Endpoint_status_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const Endpoint_status_type&);

  void
  operator<< (::xercesc::DOMElement&, const Joining_type&);

  void
  operator<< (::xercesc::DOMAttr&, const Joining_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const Joining_type&);

  void
  operator<< (::xercesc::DOMElement&, const Disconnection_type&);

  void
  operator<< (::xercesc::DOMAttr&, const Disconnection_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const Disconnection_type&);

  void
  operator<< (::xercesc::DOMElement&, const Execution_type&);

  void
  operator<< (::xercesc::DOMElement&, const Call_type&);

  void
  operator<< (::xercesc::DOMElement&, const Sip_dialog_id_type&);

  void
  operator<< (::xercesc::DOMElement&, const Media_type&);

  void
  operator<< (::xercesc::DOMElement&, const Media_status_type&);

  void
  operator<< (::xercesc::DOMAttr&, const Media_status_type&);

  void
  operator<< (::xml_schema::ListStream&,
              const Media_status_type&);

  void
  operator<< (::xercesc::DOMElement&, const Sidebars_by_val_type&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_USERS_REISBENJAMIN_DEVELOPPEMENT_FLEXISIP_SRC_XML_CONFERENCE_INFO_HXX
