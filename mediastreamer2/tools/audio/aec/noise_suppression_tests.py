#!/usr/bin/python
# 
# Copyright (c) 2010-2025 Belledonne Communications SARL.
# 
# This file is part of mediastreamer2
# (see https://gitlab.linphone.org/BC/public/mediastreamer2).
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
 
import subprocess
import glob
import os
from noise_suppression_files import NoiseSuppressionFiles
from audio_analysis_noise_suppression import AudioAnalysisNoiseSuppression

class NoiseSuppressionTest:
    """
    This class handles the data and methods related to a given test of the mediastreamer2 test suite "Noise Suppression
     in audio", in order to run it and analyze its results.
    """

    def __init__(self, test_name, **kwargs):
        """
        Initialization of the class.
        :param test_name: Name of the test function in file mediastreamer2_noise_suppression_tester.c.
        :param kwargs: Dict of optional arguments.
        """

        self.test_name = test_name
        self.suite = "Noise suppression"
        self.model = kwargs.get("model", "rnnoise").lower()

        # if self.model not in self.test_name.lower():
        #     self.test_suite_name = self.test_name + ", " + self.model
        #     self.test_name = self.test_name + "_" + self.model
        # else:
        #     self.test_suite_name = self.test_name
        #     self.test_suite_name = self.test_suite_name.replace("_" + self.model, ", " + self.model)
        # self.test_suite_name = self.test_suite_name.replace("_", " ")
        self.test_suite_name = self.test_name.replace("_", " ")

        self.build_path = kwargs.get("build path", "../../Dev/Linphone-sdk/sources/linphone-sdk/out/build/default/")
        self.tester_cmd = kwargs.get("tester cmd", "./" + self.build_path + "/bin/mediastreamer2-tester")
        self.output_path = kwargs.get("output path", self.build_path)
        self.log_file = self.output_path + self.test_name + ".log"

        self.files = NoiseSuppressionFiles()
        self.files.noisy_speech.file_name = self.output_path + "noisy_audio_" + self.test_name + ".wav"
        self.files.clean.file_name = self.output_path + "clean_audio_" + self.test_name + ".wav"
        self.start_analysis_time_ms = kwargs.get("start analysis", 0)
        self.results = None

    def run(self):
        """
        Run the related test of mediastreamer2.
        """

        print(f"\n=== run {self.test_name} ===")

        command = [self.tester_cmd, '--suite', self.suite, '--test', self.test_suite_name, '--verbose', '--log-file',
                   self.log_file]
        print(command)
        try:
            result = subprocess.run(command, check=True, capture_output=True, text=True)
            print("Output:", result.stdout)
        except subprocess.CalledProcessError as e:
            print("Error:", e.stderr)

    def move_files(self):
        """Move the file generated by the test to another folder. Make sure that the output file is not deleted at the
        end of the test. The output file is the latest wav file starting with clean_."""

        audio_file_list = glob.glob("clean_*" + self.test_name + "*.wav")
        audio_file_list.sort(key=os.path.getmtime)
        if len(audio_file_list) > 0:
            audio_file_name = audio_file_list[-1]
            print(f"move {audio_file_name}")
            file_name = self.files.clean.file_name
            print(f"into {file_name}")
            os.rename(audio_file_name, file_name)
        else:
            print(f"no audio file name matching", "clean*_" + self.test_name + "*.wav", "in build dir to move")

    def get_results(self, no_fig=False):
        """Extract the audio denoising metrics from the logs."""

        plot_silence_and_talk = not no_fig
        print(f"\nAnalyze results in file\n\t{self.log_file}")
        try:
            if self.files.clean.data is None:
                print(f"read clean audio from file {self.files.noisy_speech.file_name}")
                self.files.clean.read_audio()
            if self.files.speech.data is None:
                print(f"read speech audio from file {self.files.noisy_speech.file_name}")
                self.files.speech.read_audio()
            if self.files.noisy_speech.data is None:
                print(f"read noisy speech audio from file {self.files.noisy_speech.file_name}")
                self.files.noisy_speech.read_audio()
            self.results = AudioAnalysisNoiseSuppression(self.files.speech, self.files.noisy_speech, self.files.clean, self.model, self.test_suite_name)
            self.results.compute_denoising_quality(self.log_file, self.start_analysis_time_ms,
                                                           plot_silence_and_talk, self.files.noise)
        except FileNotFoundError:
            print(f"no audio file to analyse")
            self.results = AudioAnalysisNoiseSuppression(None, None, None, self.model)
            self.results.get_results(self.log_file)

        self.results.print()
        row = {
            "test": self.test_name,
            "model": self.model,
            "SNR": self.results.snr_dB,
            "similarity": self.results.similarity_in_speech,
            "similarity with MFCC": self.results.similarity_mfcc,
            "energy in silence": self.results.energy_in_silence,
            "energy in silence with noise": self.results.energy_in_silence_with_noise,
            "asserts": self.results.asserts,
            "test passed": self.results.test_passed,
            "time": self.results.total_time_s,
            "max pos": self.results.maxpos,
            "MSTicker late": self.results.msticker_late_ms,
            "filter count": self.results.filter_stats[0],
            "filter min time": self.results.filter_stats[1],
            "filter mean time": self.results.filter_stats[2],
            "filter max time": self.results.filter_stats[3],
            "filter std time": self.results.filter_stats[4],
            "filter CPU usage": self.results.filter_stats[5]
        }

        return row
