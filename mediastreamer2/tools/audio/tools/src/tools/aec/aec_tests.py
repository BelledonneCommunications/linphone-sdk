# Copyright (c) 2010-2025 Belledonne Communications SARL.
#
# This file is part of mediastreamer2
# (see https://gitlab.linphone.org/BC/public/mediastreamer2).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""Run and analyze the tests of the linphone-sdk suite AEC3 in mediastreamer2.

The tests are run, then the results are analyzed to measure the quality of the echo cancellation.
The metrics are read from the log file and plot with the audio signals.
An additional metric based on MFCC representation is computed.
"""

import os
from pathlib import Path
from typing import Any

from tools.aec.aec_files import AECFiles
from tools.aec.audio_analysis import AudioAnalysis
from tools.common.utils.sdk_test import SDKTest


class AECTest(SDKTest):
    """Run and analyze a test of the linphone-sdk suite AEC3 in mediastreamer2."""

    def __init__(self, test_name: str, build_path: Path, **kwargs: dict[str, Any]) -> None:
        """Define the test.

        The test is defined by test_name, and the paths needed to run it can be given in kwargs.
        :param test_name: Name of the test or the related function in file mediastreamer2_aec3_tester.c.
        :type test_name: str
        :param build_path: Path to build directory. It contains the executable at bin/mediastreamer2-tester.
        :type build_path: Path
        :param kwargs: Optional arguments to configure the test. Possible keys are:
            - "output path" (Path, optional): Path to the output directory, where the log file is written. If not
            provided, it is the build directory.
            - "start analysis" (int, optional): Time stamp taken to start the audio analysis, in ms. If not provided,
            the analysis starts at 0 ms.
        :param kwargs: dict[str, Any]
        :raises ValueError: if the mediastreamer2-tester executable is not found in build path.
        """
        SDKTest.__init__(
            self, "mediastreamer2-tester", "AEC3", test_name, build_path, kwargs.get("output path", build_path)
        )
        self.files = AECFiles()
        self.files.aec_output_clean.file_name = self.output_path + self.test_name + ".wav"
        self.files.aec_output_ref.file_name = self.output_path + "aec_output_ref_" + self.test_name + ".wav"
        self.start_analysis_time_ms = kwargs.get("start analysis", 0)
        self.alignment_interval_ms = kwargs.get("alignment interval")

    def move_files(self) -> None:
        """Move the files generated by the test to another folder.

        Make sure that AEC output file is not deleted at the end of the test.
        The output file is the latest wav file starting with aec_output.
        If found, the mic file (near-end + echo) is also moved.
        """
        # reference output if exist
        audio_file_list = list(Path.cwd().glob("aec_output_ref.wav"))
        if len(audio_file_list) > 0:
            audio_file_name = audio_file_list[-1]
            print(f"move {audio_file_name}")
            print(f"into {self.files.aec_output_ref.file_name}")
            src = Path(audio_file_name)
            dst = Path(self.files.aec_output_ref.file_name)
            src.rename(dst)
        else:
            print("no ref audio file in build dir to copy")

        audio_file_list = list(Path.cwd().glob("aec_output*.wav"))
        audio_file_list.sort(key=os.path.getmtime)
        if len(audio_file_list) > 0:
            audio_file_name = audio_file_list[-1]
            print(f"move {audio_file_name}")
            print(f"into {self.files.aec_output_clean.file_name}")
            src = Path(audio_file_name)
            dst = Path(self.files.aec_output_clean.file_name)
            src.rename(dst)
        else:
            print("no audio file in build dir to copy")

        # move also input_mic file
        src_input_mic_file_name = "aec_input_mic.wav"
        dst_input_mic_file_name = self.output_path + "aec_input_mic_" + self.test_name + ".wav"
        try:
            print(f"move {src_input_mic_file_name}")
            print(f"into {dst_input_mic_file_name}")
            src = Path(src_input_mic_file_name)
            dst = Path(dst_input_mic_file_name)
            src.rename(dst)
        except FileNotFoundError:
            print("no input mic file")

    def get_results(self, plot_fig: bool = False) -> dict[str, str | float]:
        """Get the echo cancellation quality metrics.

        Extract the AEC metrics from the logs, compute the MFCC metric, display the results and the audio.
        All the results are returned in a dictionary.
        :param plot_fig: optional, True to display the audio with silence and talk parts, False otherwise. Default is
            False.
        :type plot_fig: bool
        :return: dictionary of test results and metrics.
        :rtype: dict[str, str | float]
        """
        print(f"\nAnalyze results in file\n\t{self.log_file}")
        if self.test_name == "far_end_single_talk":
            plot_fig = False
        try:
            if self.files.aec_output_clean.data is None:
                self.files.aec_output_clean.read_audio()
            if self.files.nearend.data is None:
                self.files.nearend.read_audio()
            self.results = AudioAnalysis(self.files.nearend, self.files.aec_output_clean, self.test_suite_name)
            self.results.compute_echo_cancellation_quality(
                self.log_file, self.start_analysis_time_ms, self.alignment_interval_ms, plot_fig
            )
        except FileNotFoundError:
            print("no audio file to analyse")
            self.results = AudioAnalysis(None, None, self.test_suite_name)
            self.results.get_results(self.log_file)

        self.results.print()
        return {
            "test": self.test_name,
            "input delay": self.results.real_delay_ms,
            "estimated delay": self.results.estimated_delay_ms,
            "final ERL": self.results.aec_metrics.erl_final,
            "final ERLE": self.results.aec_metrics.erle_final,
            "similarity": self.results.similarity_in_speech,
            "max pos": self.results.maxpos,
            "energy in silence": self.results.energy_in_silence,
            "MSTicker late": self.results.msticker_late_ms,
            "test passed": self.results.test_passed,
            "time": self.results.total_time_s,
            "similarity with MFCC": self.results.similarity_mfcc,
            "filter count": self.results.filter_stats[0],
            "filter min time": self.results.filter_stats[1],
            "filter mean time": self.results.filter_stats[2],
            "filter max time": self.results.filter_stats[3],
            "filter std time": self.results.filter_stats[4],
            "filter CPU usage": self.results.filter_stats[5],
            "asserts": self.results.asserts,
        }

    def plot_results(self, fig_file_name: str = "") -> None:
        """Plot the output of AEC filter and related metrics.

        :param fig_file_name: Optional, name of the figure file. If empty, do not save the figure. Default is empy.
        :type fig_file_name: str
        """
        if self.results.aec_metrics.metrics is not None:
            fig_title = f"Acoustic Echo Cancellation during test {self.test_suite_name}"
            fig = self.results.plot_aec_metrics(fig_title)
            if fig_file_name != "":
                fig.write_image(fig_file_name)
        else:
            print("No AEC metrics to plot.")
