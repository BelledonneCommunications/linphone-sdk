# Copyright (c) 2010-2025 Belledonne Communications SARL.
#
# This file is part of mediastreamer2
# (see https://gitlab.linphone.org/BC/public/mediastreamer2).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""Analyze the quality of the acoustic echo cancellation.

The analysis is based on the metrics read in log file and other that are computed on audio data.
"""

import re

import numpy as np
import plotly.graph_objects as go

from tools.aec.aec_metrics import AecMetrics
from tools.common.audio.audio_comparison import AudioComparison
from tools.common.audio.audio_signal import AudioSignal


class AudioAnalysis:
    """Handles the analysis of audio data generated by AEC filtering."""

    def __init__(self, nearend: AudioSignal, aec_output: AudioSignal, test_name: str) -> None:
        """Set the audio signals and analysis parameters.

        :param nearend: Initial near-end speech signal without echo.
        :type nearend: AudioSignal
        :param aec_output: Filtered out signal, output of a test from the AEC3 suite.
        :type aec_output: AudioSignal
        :param test_name: Name of the test used applied to cancel the echo.
        :type test_name: str

        """
        self.nearend = nearend
        self.aec_output = aec_output
        self.test_name = test_name
        self.log_file = ""
        self.aec_metrics = AecMetrics()
        self.comparison = AudioComparison()
        self.sampling_rate_hz = 0
        self.real_delay_ms = 0
        self.estimated_delay_ms = 0
        self.energy_in_silence = 0.0
        self.similarity_in_speech = 0.0
        self.msticker_late_ms = []
        self.maxpos = 0
        self.test_passed = 1
        self.asserts = 0
        self.total_time_s = 0.0
        self.silence_mask = None
        self.start_analysis_time_ms = 0
        self.start_sample = 0
        self.distance_mfcc = 0.0
        self.similarity_mfcc = 0.0
        self.filter_stats = None

    def get_results(self, log_file: str) -> None:
        """Extract the results of the test from log.

        An AEC filtering has been applied during the test. Some information is extracted from the log file.
        :param log_file: Full file name of the log file.
        :type log_file: str
        """
        self.log_file = log_file
        metrics_lines = []
        float_pattern = r"\d+\.\d+|\d+"
        with open(log_file) as f:
            contents = f.readlines()
            for i, line in enumerate(contents):
                if "Initializing WebRTC echo canceler" in line:
                    self.sampling_rate_hz = int(line.split("with sample rate = ")[-1].split(" Hz")[0])
                    print(f"sampling rate found is {self.sampling_rate_hz} Hz")

                if "current metrics :" in line:
                    metrics_lines.append(line)

                if "estimated delay is" in line:
                    self.estimated_delay_ms = int(line.split("estimated delay is ")[-1].split(", real")[0])
                    self.real_delay_ms = int(line.split("real delay is ")[-1].split(" ms")[0])

                if "chunk - max cross-correlation obtained at position " in line and self.maxpos == 0:
                    match = re.search(
                        r"\[(-?\d+)\]",
                        line.split("obtained at position ")[-1].split(", similarity factor")[0],
                    )
                    if match:
                        self.maxpos = int(match.group(1))

                if "Max cross-correlation obtained on speech parts" in line:
                    match = re.search(r"\[([-+]?\d*\.?\d+)\]", line.split("similarity factor=")[-1])
                    if match:
                        self.similarity_in_speech = float(match.group(1))

                if "Energy measured on silences" in line:
                    match = re.search(
                        r"\[([0-9]+\.[0-9]+)\]",
                        line.split("Energy measured on silences=")[-1],
                    )
                    if match:
                        self.energy_in_silence = float(match.group(1))

                if "Energy=" in line and "aec_output_farend_single_talk" in line:
                    match = re.search(
                        r"([0-9]+\.[0-9]+)",
                        line.split("Energy=")[-1].split(" in file")[0],
                    )
                    if match:
                        self.energy_in_silence = float(match.group(1))

                if "Tester MSTicker: We are late of" in line:
                    late_str = line.split("Tester MSTicker: We are late of ")[-1].split(" miliseconds.")[0]
                    self.msticker_late_ms.append(int(late_str))

                if "FILTER USAGE STATISTICS" in line:
                    k = i + 4
                    if k < len(contents):
                        stats_line = contents[k]
                        while (
                            k < len(contents)
                            and "MSWebRTCAEC" not in stats_line
                            and "=======================" not in stats_line
                        ):
                            stats_line = contents[k]
                            k = k + 1
                        if "MSWebRTCAEC" in stats_line:
                            self.filter_stats = np.array(
                                [
                                    float(num)
                                    for num in re.findall(
                                        float_pattern,
                                        stats_line.split("MSWebRTCAEC")[1],
                                    )
                                ]
                            )

                if "Suite [AEC3] Test [" in line:
                    # Suite [AEC3] Test [Double talk]
                    if "passed in" in line:
                        self.test_passed = 1
                    elif "failed in" in line:
                        self.test_passed = 0
                    total_time_str = line.split("in ")[-1].split(" secs")[0]
                    match = re.search(r"([0-9]+\.[0-9]+)", total_time_str)
                    if match:
                        self.total_time_s = float(match.group(1))

                if "Run Summary:    Type  Total    Ran Passed Failed Inactive" in line:
                    k = i + 3
                    if k < len(contents) and "asserts" in contents[k]:
                        integers = [int(num) for num in contents[k].split() if num.isdigit()]
                        self.asserts = integers[3]

        if len(metrics_lines) > 0:
            self.aec_metrics.get_metrics_from_logs(metrics_lines)

    def print(self) -> None:
        """Print the results of the AEC test."""
        if len(self.msticker_late_ms) > 0:
            print(f"MSticker late: \t{self.msticker_late_ms} ms")
        if self.aec_metrics.metrics is not None:
            print("final AEC metrics:")
            print(f"\tdelay = {self.aec_metrics.delay_final} ms")
            print(f"\terl = {self.aec_metrics.erl_final}")
            print(f"\terle = {self.aec_metrics.erle_final}")
        print(f"estimated delay: \t\t\t{self.estimated_delay_ms} ms")
        print(f"real final delay: \t\t\t{self.real_delay_ms} ms")
        if self.aec_output is not None:
            print(
                f"maxpos: \t\t\t\t{self.maxpos} samples\n\t\t\t\t\t\
{self.maxpos * 1000.0 / self.aec_output.sample_rate_hz:0.0f} ms"
            )
        else:
            print(
                f"maxpos: \t\t\t\t{self.maxpos} samples\n\t\t\t\t\t\
{self.maxpos * 1000.0 / self.sampling_rate_hz:0.0f} ms"
            )

        print(f"energy in silence: \t\t\t{self.energy_in_silence:0.2f}")
        print(f"similarity in speech: \t\t\t{self.similarity_in_speech:0.3f}")
        print(f"           with MFCC: \t\t\t{self.similarity_mfcc:0.3f}")

        if self.filter_stats is not None:
            print(f"filter usage stats: \tcount\t\t{self.filter_stats[0]:0.0f}")
            print(f"\t\t\ttime\tmin\t{self.filter_stats[1]:0.2f} ms")
            print(f"\t\t\t\tmean\t{self.filter_stats[2]:0.2f} ms")
            print(f"\t\t\t\tmax\t{self.filter_stats[3]:0.2f} ms")
            print(f"\t\t\t\tstd\t{self.filter_stats[4]:0.2f} ms")
            print(f"\t\t\tCPU usage\t{self.filter_stats[5]:0.2f} %")

        print(f"test passed: \t\t\t\t{self.test_passed}")
        print(f"total time: \t\t\t\t{self.total_time_s:0.1f} s")

    def plot_aec_metrics(self, fig_title: str) -> go.Figure:
        """Plot the audio and the AEC metrics.

        :param fig_title: Title of the figure
        :type fig_title: str
        :return: Plotly figure
        :rtype: go.Figure
        """
        if self.aec_output.normalized_data is None:
            self.aec_output.read_audio()

        return self.aec_metrics.plot_with_audio(self.aec_output.timestamps, self.aec_output.normalized_data, fig_title)

    def compute_echo_cancellation_quality(
        self,
        log_file: str,
        start_analysis_ms: int = 0,
        alignment_interval_ms: [int, int] = None,
        plot_silence_and_talk: bool = True,
    ) -> None:
        """Compute or load criteria to measure the quality of the acoustic echo cancellation.

        :param log_file: Full file name of the log file that contains the traces of the test.
        :type log_file: str
        :param start_analysis_ms: Time stamp to start the audio analysis, in ms. Default is 0.
        :type start_analysis_ms: int
        :param alignment_interval_ms: Begin and end of the small time interval taken to align the clean audio on the
            speech audio. If not given, the correlation is computed on the whole signal, but it takes more time. Default
            is None.
        :type alignment_interval_ms: [int, int]
        :param plot_silence_and_talk: True whether the audio must be plotted with silence and talk parts. Default is
            True.
        :type plot_silence_and_talk: bool
        """
        # load results in log file
        self.get_results(log_file)

        if self.aec_output.data is not None:
            self.comparison.set_audio(self.aec_output, self.nearend)

            # align
            print("--- align on reference and detect silence ---")
            self.start_sample = self.comparison.set_start_analysis(start_analysis_ms)
            if self.nearend.data is not None:
                self.comparison.truncate_reference()
                self.comparison.align_signal_on_reference(
                    self.aec_output, self.nearend, start_analysis_ms, alignment_interval_ms
                )
                self.comparison.truncate_aligned_end_to_same_size([self.nearend, self.aec_output])

                # detect silence and talk
                self.comparison.detect_silence()
                if plot_silence_and_talk:
                    fig_title = f"Silence and talk to compare, {self.test_name}"
                    legend = ["Near-end", "AEC output"]
                    fig = self.comparison.plot_silence_and_talk(fig_title, legend)
                    fig.write_image(self.log_file.replace(".log", "_silence_talk.png"))

            else:
                self.comparison.silence_mask = np.ones_like(self.aec_output.data[self.start_sample :], dtype=bool)
                self.aec_output.silence = self.aec_output.data[self.start_sample :]

            # compute energy remaining in silence of noisy audio and clean audio
            print("--- energy in silence ---")
            energy_in_silence = self.comparison.compute_energy_difference()[0]
            if self.energy_in_silence == 0.0:
                self.energy_in_silence = energy_in_silence

            # compute speech similarity
            if self.nearend.talk is not None:
                print("--- similarity in talk ---")
                file_name_base = self.log_file.split(".log")[0]
                self.similarity_mfcc, self.distance_mfcc = self.comparison.compute_acoustic_similarity(file_name_base)
